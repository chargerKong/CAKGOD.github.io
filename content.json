[{"title":"markdown使用总结","date":"2021-02-04T02:48:26.000Z","path":"2021/02/04/markdown使用总结/","text":"Markdown使用教程1、简介2、Markdown标题Markdown 标题有两种格式。 （1）使用 = 和 - 标记一级和二级标题= 和 - 标记语法格式如下： 我展示的是一级标题 ================= 我展示的是二级标题 ----------------- （2）使用 # 号标记# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 3、Markdown 段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 当然也可以在段落后面使用一个空行来表示重新开始一个段落。 4、Markdown字体Markdown 可以使用以下几种字体： *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 5、Markdown分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** * * * ***** - - - ---------- 6、Markdown删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： RUNOOB.COM GOOGLE.COM ~~BAIDU.COM~~ 7、Markdown下划线下划线可以通过 HTML 的 标签来实现： &lt;u&gt;带下划线文本&lt;/u&gt; 8、Markdown脚注脚注是对文本的补充说明。 Markdown 脚注的格式如下: [^要注明的文本] 以下实例演示了脚注的用法： 创建脚注格式类似这样 [^RUNOOB]。 [^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！ 9、Markdown列表Markdown 支持有序列表和无序列表。 无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 有序列表使用数字并加上 . 号来表示，如： 1. 第一项 2. 第二项 3. 第三项 列表嵌套只需在子列表中的选项前面添加四个空格即可： 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 10、Markdown区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： &gt; 区块引用 &gt; 菜鸟教程 &gt; 学的不仅是技术更是梦想 另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推： &gt; 最外层 &gt; &gt; 第一层嵌套 &gt; &gt; &gt; 第二层嵌套 区块中使用列表实例如下： &gt; 区块中使用列表 &gt; 1. 第一项 &gt; 2. 第二项 &gt; + 第一项 &gt; + 第二项 &gt; + 第三项 如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。 区块中使用列表实例如下： * 第一项 &gt; 菜鸟教程 &gt; 学的不仅是技术更是梦想 * 第二项 11、Markdown代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如： `printf()` 函数 代码区块使用 4 个空格或者一个制表符（Tab 键）。 也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： ​```javascript $(document).ready(function () &#123; alert(&#39;RUNOOB&#39;); &#125;); ​ ## 12、Markdown链接 链接使用方法如下： 链接名称 或者 &lt;链接地址&gt; 例如： 这是一个链接 菜鸟教程 可以通过变量来设置一个链接，变量赋值在文档末尾进行： 这个链接用 1 作为网址变量 Google这个链接用 runoob 作为网址变量 Runoob然后在文档的结尾为变量赋值（网址） ## 13、Markdown图片 Markdown 图片语法格式如下： - 开头一个感叹号 ! - 接着一个方括号，里面放上图片的替代文字 - 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 &#39;title&#39; 属性的文字。 使用示例： 当然，也可以像网址那样对图片网址使用变量:. 这个链接用 1 作为网址变量 RUNOOB.然后在文档的结尾为变量赋值（网址） Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 ## 14、Markdown表格 Markdown 制作表格使用 **|** 来分隔不同的单元格，使用 **-** 来分隔表头和其他行。 语法格式如下： 表头 表头 单元格 单元格 单元格 单元格 **可以设置表格的对齐方式：** - **-:** 设置内容和标题栏居右对齐。 - **:-** 设置内容和标题栏居左对齐。 - **:-:** 设置内容和标题栏居中对齐。 示例如下： 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 ## 15、Markdown 高级技巧 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：`&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;`等 ，如： 使用 Ctrl+Alt+Del 重启电脑 Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 文本加粗** 正常显示星号 ** Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线` 反引号 星号_ 下划线{} 花括号[] 方括号() 小括号井字号 加号 减号. 英文句点! 感叹号``` 当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： $$ \\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\ \\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\ \\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\ \\end&#123;vmatrix&#125; $&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125; $$"},{"title":"使用turtlebot2和速腾聚创雷达搭建移动机器人数据采集平台","date":"2021-02-04T01:47:46.000Z","path":"2021/02/04/使用turtlebot2和速腾聚创雷达搭建移动机器人数据采集平台/","text":"之前一段时间在Navigation2社区进行贡献，鉴于目前通用的数据集是用于自动驾驶的，社区Leader Steve对移动机器人数据集提出了需求，同时提出了需要考虑到多数开发者控制成本的要求。为此，特意购置了速腾聚创的16线雷达，以及Turtlebot2移动机器人来组装该平台。 硬件部分整套设备由速腾聚创雷达、Xsens惯导、Turtlebot2、Mini PC以及两块电源组成。为了保证雷达有足够的视野，需要将雷达安装在Turtlebot2的最顶部，将电源通过转接器进行电压转化对雷达进行供电。Xsens固定在雷达垂直的位置上，保证相对位置固定，通过Mini PC的数据线连接供电。Mini PC通过同样电源的方法进行供电，并通过网线和雷达连接，通过数据线和Turtlebot连接。Turtlebot本身充满电即可。最后的组装的完整设备如下图所示。 软件部分 在Mini PC上安装相关软件 安装ubuntu 18.04 安装ROS melodic 安装Turtlebot相关软件sudo apt install ros-melodic-kobuki-*sudo apt install ros-melodic-ecl-streamssudo apt install libusb-devsudo apt install libspnav-devsudo apt install ros-melodic-joystick-driverssudo apt install libbluetooth-devsudo apt install libcwiid-devsudo apt install ros-melodic-robot-pose-ekf 准备SDK软件mkdir -p ~/turtlebot_ws/srccd ~/turtlebot_ws/srcgit clone https://github.com/turtlebot/turtlebot_simulatorgit clone https://github.com/turtlebot/turtlebot.git​git clone https://github.com/turtlebot/turtlebot_apps.gitgit clone https://github.com/udacity/robot_pose_ekf​git clone https://github.com/ros-perception/depthimage_to_laserscan.gitgit clone https://github.com/yujinrobot/kobuki_msgs.gitgit clone https://github.com/yujinrobot/kobuki_desktop.gitcd kobuki_desktop/​rm -r kobuki_qtestsuitegit clone https://github.com/toeklk/orocos-bayesian-filtering.gitgit clone https://github.com/turtlebot/turtlebot_msgs.gitgit clone https://github.com/ros-drivers/joystick_drivers.git 将kobuki和yujin_ocs依赖复制到turtlebot/src/​mkdir -p ~/repos/cd ~/repos/​git clone https://github.com/yujinrobot/kobuki.git​cp -r kobuki/* ~/turtlebot_ws/src/​git clone https://github.com/yujinrobot/yujin_ocs.git​cp -r yujin_ocs/yocs_cmd_vel_mux/ yujin_ocs/yocs_controllers ~/turtlebot_ws/src/ 编译 cd ~/turtlebot_wssource /opt/ros/melodic/setup.bashcatkin_make 将工作空间添加到bashrc文件中echo &quot;source ~/turtlebot_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc source `source ~/.bashrc 安装Xsens惯导软件 首先安装mti670驱动，从MT SDK文件夹中将 xsens_ros_mti_driver文件夹复制到catkin工作目录的src文件夹中，使用chmod 777命令对所有文件夹和文件添加权限，然后使用pushd src/xsens_ros_mti_driver/lib/xspublic &amp;&amp; make &amp;&amp; popd命令编译xspublic，最后使用catkin_make编译Mti驱动文件夹。 其他 使用 将各个线连接好 启动Turtlebot2 roslaunch turtlebot_bringup minimal.launch 将会看以下信息 ubuntu@AiROS-XA:~/turtlebot_ws/src$ roslaunch turtlebot_bringup minimal.launch ... logging to /home/ubuntu/.ros/log/a22c211a-7888-11e9-8396-00044bcb943f/roslaunch-AiROS- XA-6402.log Checking log directory for disk usage. This may take awhile. Press Ctrl-C to interrupt Done checking log file disk usage. Usage is &lt;1GB. xacro: in-order processing became default in ROS Melodic. You can drop the option. started roslaunch server http://AiROS-XA:41151/ SUMMARY ======== PARAMETERS * /bumper2pointcloud/pointcloud_radius: 0.24 * /cmd_vel_mux/yaml_cfg_file: /home/ubuntu/turt... * /diagnostic_aggregator/analyzers/input_ports/contains: [&#39;Digital Input&#39;,... * /diagnostic_aggregator/analyzers/input_ports/path: Input Ports * /diagnostic_aggregator/analyzers/input_ports/remove_prefix: mobile_base_nodel... * /diagnostic_aggregator/analyzers/input_ports/timeout: 5.0 * /diagnostic_aggregator/analyzers/input_ports/type: diagnostic_aggreg... * /diagnostic_aggregator/analyzers/kobuki/contains: [&#39;Watchdog&#39;, &#39;Mot... * /diagnostic_aggregator/analyzers/kobuki/path: Kobuki * /diagnostic_aggregator/analyzers/kobuki/remove_prefix: mobile_base_nodel... * /diagnostic_aggregator/analyzers/kobuki/timeout: 5.0 * /diagnostic_aggregator/analyzers/kobuki/type: diagnostic_aggreg... * /diagnostic_aggregator/analyzers/power/contains: [&#39;Battery&#39;, &#39;Lapt... * /diagnostic_aggregator/analyzers/power/path: Power System * /diagnostic_aggregator/analyzers/power/remove_prefix: mobile_base_nodel... * /diagnostic_aggregator/analyzers/power/timeout: 5.0 * /diagnostic_aggregator/analyzers/power/type: diagnostic_aggreg... * /diagnostic_aggregator/analyzers/sensors/contains: [&#39;Cliff Sensor&#39;, ... * /diagnostic_aggregator/analyzers/sensors/path: Sensors * /diagnostic_aggregator/analyzers/sensors/remove_prefix: mobile_base_nodel... * /diagnostic_aggregator/analyzers/sensors/timeout: 5.0 * /diagnostic_aggregator/analyzers/sensors/type: diagnostic_aggreg... * /diagnostic_aggregator/base_path: * /diagnostic_aggregator/pub_rate: 1.0 * /mobile_base/base_frame: base_footprint * /mobile_base/battery_capacity: 16.5 * /mobile_base/battery_dangerous: 13.2 * /mobile_base/battery_low: 14.0 * /mobile_base/cmd_vel_timeout: 0.6 * /mobile_base/device_port: /dev/kobuki * /mobile_base/odom_frame: odom * /mobile_base/publish_tf: True * /mobile_base/use_imu_heading: True * /mobile_base/wheel_left_joint_name: wheel_left_joint * /mobile_base/wheel_right_joint_name: wheel_right_joint * /robot/name: turtlebot * /robot/type: turtlebot * /robot_description: &lt;?xml version=&quot;1.... * /robot_state_publisher/publish_frequency: 5.0 * /rosdistro: melodic * /rosversion: 1.14.3 * /use_sim_time: False NODES / bumper2pointcloud (nodelet/nodelet) cmd_vel_mux (nodelet/nodelet) diagnostic_aggregator (diagnostic_aggregator/aggregator_node) mobile_base (nodelet/nodelet) mobile_base_nodelet_manager (nodelet/nodelet) robot_state_publisher (robot_state_publisher/robot_state_publisher) auto-starting new master process[master]: started with pid [6415] ROS_MASTER_URI=http://localhost:11311 setting /run_id to a22c211a-7888-11e9-8396-00044bcb943f process[rosout-1]: started with pid [6426] started core service [/rosout] process[robot_state_publisher-2]: started with pid [6434] process[diagnostic_aggregator-3]: started with pid [6435] process[mobile_base_nodelet_manager-4]: started with pid [6440] process[mobile_base-5]: started with pid [6444] process[bumper2pointcloud-6]: started with pid [6448] process[cmd_vel_mux-7]: started with pid [6451] 启动键盘控制 运行$roslaunch turtlebot_teleop keyboard_teleop.launch，屏幕上会出现以下信息： ubuntu@AiROS-XA:~$ roslaunch turtlebot_teleop keyboard_teleop.launch ... logging to /home/ubuntu/.ros/log/a22c211a-7888-11e9-8396-00044bcb943f/roslaunch-AiROS-XA-6533.log Checking log directory for disk usage. This may take awhile. Press Ctrl-C to interrupt Done checking log file disk usage. Usage is &lt;1GB. started roslaunch server http://AiROS-XA:41229/ SUMMARY ======== PARAMETERS * /rosdistro: melodic * /rosversion: 1.14.3 * /turtlebot_teleop_keyboard/scale_angular: 1.5 * /turtlebot_teleop_keyboard/scale_linear: 0.5 NODES / turtlebot_teleop_keyboard (turtlebot_teleop/turtlebot_teleop_key) ROS_MASTER_URI=http://localhost:11311 process[turtlebot_teleop_keyboard-1]: started with pid [6552] Control Your Turtlebot! --------------------------- Moving around: u i o j k l m , . q/z : increase/decrease max speeds by 10% w/x : increase/decrease only linear speed by 10% e/c : increase/decrease only angular speed by 10% space key, k : force stop anything else : stop smoothly CTRL-C to quit currently: speed 0.2 turn 1 启动雷达 通过$roslaunch rslidar_pointcloud rs_lidar_32.launch启动雷达和Rviz并且此时可以再Rviz中看到点云。 启动Xsens惯导 roslaunch xsens_mti_driver xsens_mti_node.launch 此时可以接收到雷达和IMU的topic了，使用rosbag record ***.bag &lt;topic名字&gt;"},{"title":"vim使用总结","date":"2021-02-04T01:43:39.000Z","path":"2021/02/04/vim使用总结/","text":"在vim中多开窗口并切换 (1) use :sp or :vs to split the windows(2) press the ctrl+w firstly, then press h to switch to the left window (in the same way, ctrl+w j to the down window, ctrl+w k to the up window, ctrl+w l to the right window) markdownif I want to view the markdown file (1) install the &quot;markdown-preview.vim&quot; plugin (2) use :MarkdownPreview to view it in the browser move the cursor(1) move the cursor to the first line of a file :0 or :1 gg (2) move the cursor to the last line of a file : G shift+g (3) move the cursor to the head of a line Home ^ also shift+6 0 (4) move the cursor to the tail of a line End shift+4 to move the cursor to the tail of the current line (5) shortcuts: search:/&lt;word you search&gt; (6) open fileif vim is not launched: vim &lt;file1_name&gt; &lt;file2_name&gt; &lt;file3_name&gt; ...if vim is launched: :open &lt;file_name&gt; (7) switch files in the opened filesswitch files in the last two opened files: ctrl + 6next file :bnlast file :bp (8) revokerevoke the last operation :n n u recover the revoke operation `ctrl + r`"},{"title":"SVD奇异值分解","date":"2021-02-02T12:14:55.000Z","path":"2021/02/02/SVD奇异值分解/","text":"奇异值分解是线性代数中一种重要的矩阵分解方法，本文通过一个具体的例子来说明如何对一个矩阵A进行奇异值分解。 首先，对于一个m*n的矩阵，如果存在正交矩阵U(m*m阶)和V(n*n阶)，使得(1)式成立： \\begin{equation} \\begin{split} A &= UΣV^T \\end{split} \\end{equation}\\tag{1}则将式(1)的过程称为奇异值分解，其中$Σ_{mn}=\\begin{bmatrix}a &amp; b\\\\c &amp; d\\end{bmatrix}$，且$Σ_1=diag(σ_1,σ_2,…,σ_r)$，U和V分别称为A的左奇异向量矩阵和右奇异向量矩阵。下面用一个具体的例子来说明如何得到上述的分解。 对于矩阵$A=\\begin{bmatrix}1&amp;1\\\\1&amp;1\\\\0&amp;0\\end{bmatrix}$, 第一步计算U，计算矩阵$AA^T=\\begin{bmatrix}2&amp;2&amp;0\\\\2&amp;2&amp;0\\\\0&amp;0&amp;0\\end{bmatrix}$，对其进行特征分解，分别得到特征值4，0，0和对应的特征向量$[\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}},0]^T$,$[-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}},0]^T$,$[0,0,1]^T$，可以得到$U=\\begin{bmatrix}\\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}}&amp;0\\\\\\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}&amp;0\\\\0&amp;0&amp;1\\end{bmatrix}$ 第二步计算V，$A^TA=\\begin{bmatrix}2&amp;2\\\\2&amp;2\\end{bmatrix}$，对其进行特征分解，分别得到特征值4，0和对应的特征向量$[\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}]^T$，$[-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}]^T$，可以得到$V=\\begin{bmatrix}\\frac{1}{\\sqrt{2}}&amp;-\\frac{1}{\\sqrt{2}}\\\\\\frac{1}{\\sqrt{2}}&amp;\\frac{1}{\\sqrt{2}}\\end{bmatrix}$ 第三部计算$Σ_{mn}=\\begin{bmatrix}Σ_1&amp;0\\\\0&amp;0\\end{bmatrix}$，其中$Σ_1=diag(σ_1,σ_2,…,σ_r)$是将第一或第二步求出的非零特征值从大到小排列后开根号的值，这里$Σ=\\begin{bmatrix}2&amp;0\\\\0&amp;0\\\\0&amp;0\\end{bmatrix}$ 最终，我们可以得到A的奇异值分解 \\begin{equation} \\begin{split} A &= UΣV^T= \\begin{bmatrix}\\frac{1}{\\sqrt{2}}&-\\frac{1}{\\sqrt{2}}&0\\\\\\frac{1}{\\sqrt{2}}&\\frac{1}{\\sqrt{2}}&0\\\\0&0&1\\end{bmatrix} \\begin{bmatrix}2&0\\\\0&0\\\\0&0\\end{bmatrix} \\begin{bmatrix}\\frac{1}{\\sqrt{2}}&-\\frac{1}{\\sqrt{2}}\\\\\\frac{1}{\\sqrt{2}}&\\frac{1}{\\sqrt{2}}\\end{bmatrix} ^T=\\begin{bmatrix}1&1\\\\1&1\\\\0&0\\end{bmatrix} \\end{split} \\end{equation} 矩阵的特征值分解和奇异值分解有什么区别？ 首先，特征值只能作用在一个m*m的正方矩阵上，而奇异值分解则可以作用在一个m*n的长方矩阵上。其次，奇异值分解同时包含了旋转、缩放和投影三种作用，(1)式中，U和V都起到了对A旋转的作用，而Σ起到了对A缩放的作用。特征值分解只有缩放的效果。"},{"title":"k-core算法","date":"2021-01-28T09:09:15.000Z","path":"2021/01/28/k-core算法/","text":"k-core算法在图论中，k-degenerate（k简并）图是一种每个子图都有一个度不超过k的顶点的无向图，即子图中的某个顶点接触子图的k条或更少的边。图的degeneracy（简并度）是k简并的k的最小值。图的简并度是对它的稀疏程度的度量，并且是在其他稀疏度量的常数因子内，例如图的树状度。 简并度也被称为k-core数（num）、宽度（width）、和连锁（linkage），本质上与着色数（coloring number）或Szekeres-Wilf number（以Szekeres和Wilf(1968)命名）相同。k简并图也被称为k-inductive（k归纳）图。图的简并度可以通过反复删除最小度顶点的算法在线性时间内计算。去掉所有小于k度的顶点后剩下的连通分量称为图的k-cores（k核），图的简并度为具有k核的k的最大值。 如图所示是一张2-core图，每个顶点在其左边最多有两个邻居，因此任何子图的最右顶点的度最多为2。它的2核，即反复删除度数小于2的顶点后剩下的子图，是阴影的。 正如Matula &amp; Beck（1983）所描述的，在线性时间内，通过使用一个桶队列反复寻找并移除最小度的顶点，可以找到优化排序着色数的有限图G的顶点排序。那么简并度就是任何顶点在被移除时的最高度。设图中的节点数为n。更详细地说，该算法是这样进行的： 初始化一个输出列表L。 对G中的每个顶点v计算一个数字dv，即v不存在于l中的邻居数。最初，这些数字只是顶点的度数。 初始化一个数组D，使D[i]包含一个不在L中dv = i的顶点v的列表。 将k初始化为0。 重复n次: 扫描阵列单元D[0]， D[1]，…直到找到一个D[i]非空的i为止。 从D[i]中选择一个顶点v。在L的开头加上v，然后从D[i]中删除v。 对于v的每一个未在L中的相邻w，从dw中减去1，然后将w移到对应dw新值的D单元中。 在算法的最后，k包含G的简并性，L包含一个顶点列表，该顶点以最优的着色数排序。G的i核是L的前缀，由k先取大于等于i的值后添加到L的顶点组成。初始化变量L, dv, D和k可以很容易地在线性时间内完成。查找每个连续移除的顶点v，并调整包含v的邻居的D的单元，所花费的时间与该步骤dv的值成正比；但是这些值的总和就是图上的边的数量(每条边对后面的顶点的总和都有贡献)，所以总时间是线性的。"},{"title":"Boss直聘折腾","date":"2021-01-28T08:59:31.000Z","path":"2021/01/28/Boss直聘折腾/","text":"Boss直聘折腾记录"},{"title":"github用户分析","date":"2021-01-25T08:22:50.000Z","path":"2021/01/25/github用户分析/","text":"项目介绍Github作为全球最大的开源代码托管平台，存在着非常多的技术人员和宝贵的项目，这些都是非常难得的分析资源，对它们进行分析具有非常高的价值。 用户分析鉴于Github用户过多，进行全量的分析是不现实的。由于最近团队在洞察Rust社区，选择对其中的贡献者进行分析。首先需要获得所有的Rust贡献者，这里有两种方法获得。 （1）爬取Crates.io（Rust社区所有crates的介绍网站）上的所有贡献者信息，可以有API来获取。不过这种方法需要进行长时间的爬取，比较繁琐。 （2）Rust官方有一个thanks仓库，里面可以获得所有的贡献者名称。可以按照该仓库的使用介绍来获得ALL-TIME的贡献者名称。 得到具体的用户login后，可以调用Github API来获得贡献者的基本信息和相关关系。其中用户间的的关系我首先使用了following关系（后续可以添加follows、sponsors、sponsoring关系等），使用https://api.github.com/users/&lt;user-login&gt;/following来下载关系信息，使用https://api.github.com/users/&lt;user-login&gt;来下载基本信息。 得到用户的基本信息和相互的关系信息后，以人为节点建立知识图谱。个人偏好的工具有Networkx和Neo4j，都是非常好用的软件，其中Networkx可以使用python调用，Neo4j具有一套自己的图数据库系统。简单进行分析的话我选择Networkx。 从基本信息文件中抽取login作为节点名称，id、node_id、name、compony、blog、location、email、twitter_username、public_repos、public_gists、followers、following、bio、created_at、updated_at、avatar_url、html_url作为节点属性，建立单个节点。 从关系信息文件中抽取following关系作为两个节点之间的联系。"},{"title":"在linux终端优雅地打印JSON文件","date":"2021-01-25T07:30:53.000Z","path":"2021/01/25/在linux终端优雅地打印JSON文件/","text":"JSON 文件非常棒，因为它们以人类可读的格式存储数据集合。然而，如果 JSON 文件被最小化过，那么阅读 JSON 文件可能会很痛苦。以下面的JSON文件为例。 &#123;&quot;login&quot;: &quot;gperinazzo&quot;, &quot;id&quot;: 9922687, &quot;node_id&quot;: &quot;MDQ6VXNlcjk5MjI2ODc=&quot;, &quot;avatar_url&quot;: &quot;https://avatars0.githubusercontent.com/u/9922687?v=4&quot;, &quot;gravatar_id&quot;: &quot;&quot;, &quot;url&quot;: &quot;https://api.github.com/users/gperinazzo&quot;, &quot;html_url&quot;: &quot;https://github.com/gperinazzo&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/users/gperinazzo/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/users/gperinazzo/following&#123;/other_user&#125;&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/users/gperinazzo/gists&#123;/gist_id&#125;&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/users/gperinazzo/starred&#123;/owner&#125;&#123;/repo&#125;&quot;, &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/gperinazzo/subscriptions&quot;, &quot;organizations_url&quot;: &quot;https://api.github.com/users/gperinazzo/orgs&quot;, &quot;repos_url&quot;: &quot;https://api.github.com/users/gperinazzo/repos&quot;, &quot;events_url&quot;: &quot;https://api.github.com/users/gperinazzo/events&#123;/privacy&#125;&quot;, &quot;received_events_url&quot;: &quot;https://api.github.com/users/gperinazzo/received_events&quot;, &quot;type&quot;: &quot;User&quot;, &quot;site_admin&quot;: false, &quot;name&quot;: null, &quot;company&quot;: null, &quot;blog&quot;: &quot;&quot;, &quot;location&quot;: null, &quot;email&quot;: &quot;gperinazzo@gmail.com&quot;, &quot;hireable&quot;: null, &quot;bio&quot;: null, &quot;twitter_username&quot;: null, &quot;public_repos&quot;: 21, &quot;public_gists&quot;: 0, &quot;followers&quot;: 4, &quot;following&quot;: 0, &quot;created_at&quot;: &quot;2014-11-24T01:48:29Z&quot;, &quot;updated_at&quot;: &quot;2020-11-08T00:34:34Z&quot;&#125; 计算机可以很容易地读取它。即使是人也能读，但如果 JSON 文件以合适的格式显示，那么阅读就会简单很多。理想中的 JSON 文件应该是这样读的： &#123; &quot;login&quot;: &quot;gperinazzo&quot;, &quot;id&quot;: 9922687, &quot;node_id&quot;: &quot;MDQ6VXNlcjk5MjI2ODc=&quot;, &quot;avatar_url&quot;: &quot;https://avatars0.githubusercontent.com/u/9922687?v=4&quot;, &quot;gravatar_id&quot;: &quot;&quot;, &quot;url&quot;: &quot;https://api.github.com/users/gperinazzo&quot;, &quot;html_url&quot;: &quot;https://github.com/gperinazzo&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/users/gperinazzo/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/users/gperinazzo/following&#123;/other_user&#125;&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/users/gperinazzo/gists&#123;/gist_id&#125;&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/users/gperinazzo/starred&#123;/owner&#125;&#123;/repo&#125;&quot;, &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/gperinazzo/subscriptions&quot;, &quot;organizations_url&quot;: &quot;https://api.github.com/users/gperinazzo/orgs&quot;, &quot;repos_url&quot;: &quot;https://api.github.com/users/gperinazzo/repos&quot;, &quot;events_url&quot;: &quot;https://api.github.com/users/gperinazzo/events&#123;/privacy&#125;&quot;, &quot;received_events_url&quot;: &quot;https://api.github.com/users/gperinazzo/received_events&quot;, &quot;type&quot;: &quot;User&quot;, &quot;site_admin&quot;: false, &quot;name&quot;: null, &quot;company&quot;: null, &quot;blog&quot;: &quot;&quot;, &quot;location&quot;: null, &quot;email&quot;: &quot;gperinazzo@gmail.com&quot;, &quot;hireable&quot;: null, &quot;bio&quot;: null, &quot;twitter_username&quot;: null, &quot;public_repos&quot;: 21, &quot;public_gists&quot;: 0, &quot;followers&quot;: 4, &quot;following&quot;: 0, &quot;created_at&quot;: &quot;2014-11-24T01:48:29Z&quot;, &quot;updated_at&quot;: &quot;2020-11-08T00:34:34Z&quot; &#125; 可以使用大多数的文本编辑器和一些插件以合适的格式显示它。然而，如果在终端中，或者想在 shell 脚本中这么做，事情会有所不同。对于一个已最小化过的 JSON 文件，有同样的办法在 Linux 终端中漂亮地输出它。 jq 是一个命令行 JSON 处理器。可以用它来切分、过滤、映射和转换结构化数据。可以使用 apt 命令在 Ubuntu 上安装它： sudo apt install jq jq . ***.json 或者 cat ***.json | jq 如果想用漂亮的格式修改原来的 JSON 文件，可以把解析后的输出结果用管道传送到一个新的文件中，然后覆盖原来的 JSON 文件。 jq . ***.json &gt; ###.json 对一个格式良好的 JSON 文件进行最小化，可以使用选项 -c。 jq -c &lt; ###.json 如果系统中安装有python3，可以再终端中使用以下命令： python3 -m json.tool ***.json"},{"title":"keyword_extraction","date":"2021-01-12T06:14:54.000Z","path":"2021/01/12/keyword-extraction/","text":"关键词提取简介关键字提取(又称关键字检测或关键字分析)是一种文本分析技术，可以自动从文本中提取最常用、最重要的单词和表达式，它有助于总结文本内容和识别讨论的主要话题。 文本分析使用带有自然语言处理(NLP)的机器学习人工智能(AI)来分解人类语言，使其能够被机器理解和分析。关键字分析可以从各种文本中找到关键字：常规文件和商业报告，社交媒体评论，在线论坛和评论，新闻报道，等等。假设您想分析关于您的产品的数千条在线评论。关键字提取可以帮助您筛选整个数据集，并在几秒钟内获得最适合描述每个评论的词。通过这种方式，您可以很容易地自动地看到您的客户最经常提到的内容，从而为您的团队节省数小时的手工处理时间。 有一些免费的词云生成器可以比较直观地体现关键词，例如Word clouds。 方法 Simple Statistical Approaches 主要包括词频、词搭配和共现、TF-IDF(术语频率反向文档频率的缩写)和RAKE(快速自动关键字提取)，基于统计的方法只依赖于统计数据，可能会忽略那些只被提到一次但仍然应该被认为是相关的相关单词或短语。 1、词频 词频包括列出在一篇文章中重复次数最多的单词和短语。这对于很多目的都很有用，从在一组产品评审中识别反复出现的术语，到发现客户支持交互中最常见的问题。然而，词频方法认为文档只是一个“单词袋”，而不考虑与含义、结构、语法和单词序列相关的关键方面。例如，这种关键字提取方法无法检测到同义词，从而忽略了非常有价值的信息。 2、单词搭配和共现 也被称为N-gram统计，单词搭配和共现有助于理解文本的语义结构，并将多个单词算作一个单词。搭配是指经常放在一起的词。最常见的搭配类型是bi-grams(两个相邻的词，如“客户服务”、“视频电话”或“电子邮件通知”)和trig(三个词组成的组，如“易于使用”或“社交媒体渠道”)。另一方面，共现现象是指在同一语料库中倾向于共现的单词。它们不一定是相邻的，但它们在语义上确实具有相似性。 3、TF-IDF TF-IDF表示词频-逆文档频率，用来衡量文档集合中一个单词对文档的重要性。该度量计算单词在文本中出现的次数(术语频率)，并将其与逆向文档频率(该单词在整个数据集中的罕见或常见程度)进行比较，将这两个量相乘就提供了文档中单词的TF-IDF分数。分数越高，这个词就越与文档相关。当涉及到关键字提取时，这个指标可以帮助您识别文档中最相关的词(得分较高的词)，并将它们视为关键词。 4、RAKE 快速自动关键字提取(RAKE)是一种著名的关键字提取方法，它使用stopwords和短语分隔符列表来检测一段文本中最相关的单词或短语，以以下文本为例:Keyword extraction is not that difficult after all. There are many libraries that can help you with keyword extraction. Rapid automatic keyword extraction is one of those.该方法所做的第一件事是将文本拆分为一个单词列表，并从该列表中删除stopwords。这将返回一个所谓内容词的列表。假设我们的stopwords和短语分隔符列表如下:stopwords = [is, not, that, there, are, can, you, with, of, those, after, all, one] 分隔符=[., ,]然后，我们的8个内容词的列表将像这样:content_words =[keyword, extraction, difficult, many, libraries, help, rapid, automatic]然后，该算法以短语分隔符和停止词分隔文本，以创建候选表达式。所以，候选人的关键短语如下:Keyword extraction is not that difficult after all. There are many libraries that can help you with keyword extraction. Rapid automatic keyword extraction is one of those.一旦文本被分割，该算法就会创建一个单词共现矩阵。每一行显示一个给定的内容词与候选短语中每个其他内容词共现的次数。对于上面的例子，矩阵看起来像这样: 在这个矩阵建立之后，单词会得到一个分数。这一点可以计算为一个词的程度在矩阵(即共生的数量的总和词与其他词在文本内容),随着词频的次数(即这个词出现在文本),或作为其频率除以这个词的程度。如果我们计算每个单词的学位分数除以频率分数，它们看起来会像这样: 这些表达式也会给出一个分数，这个分数是每个单词的分数之和。如果我们要计算上面粗体部分的得分，它们会是这样的: 如果两个关键字或关键字短语以相同的顺序同时出现两次以上，不管关键字短语在原始文本中包含多少stopwords，都会创建一个新的关键字短语。该关键字的得分计算方式与单个关键字的得分计算方式相同。如果一个关键字或关键字短语的分数属于top T分数，其中T是您想要提取的关键字的数目，则选择该关键字或关键字短语。根据原始论文，T默认了文件中三分之一的内容词。对于上面的示例，该方法将返回前3个关键字，根据我们定义的分数，这将是rapid automatic keyword extraction(13.33)、keyword extraction(5.33)和many libraries(4.0)。 语言学方法 关键词提取方法通常利用关于文本及其包含的单词的语言信息。有时，使用词法或句法信息(例如单词的词性或句子的依赖语法表示中单词之间的关系)来确定应该提取哪些关键字。在某些情况下，某些PoS会得到更高的分数(例如名词和名词短语)，因为它们通常比其他类别包含更多关于文本的信息。 图论方法 基于图的关键字提取的基本思想总是相同的:根据从图的结构中获取的一些信息来度量顶点的重要性，从而提取最重要的顶点。一旦建立了一个图，就该确定如何度量顶点的重要性了。有许多不同的选择，其中大部分在本文中处理。有些方法选择测量顶点的度数。顶点的度等于边的数量或连接顶点的土地(也称为度)+边的数量开始的顶点(也称为度)除以最大度(=图的顶点数- 1)。这个公式来计算一个顶点的度: Dv = (Dvin + Dvout) / (N - 1) 其他一些方法测量到一个给定顶点的直接顶点的数量(称为邻域大小)。 无论选择的度量是什么，每个顶点都会有一个分数，它将决定是否将其作为关键字提取。以以下文本为例:Automatic1 graph-based2 keyword3 extraction4 is pretty5 straightforward6. A document7 is represented8 as a graph9 and a score10 is given11 to each of the vertices12 in the graph13. Depending14 on the score15 of a vertex16, it might be chosen17 as a keyword18.如果我们衡量社区大小上面的示例图的依赖性只包含有实词(编号1 - 18在文本),提取的关键词会被自动等基于关键字提取自附近的大小头名词提取(等于3/17)是最高的。 机器学习方法 1、条件随机域条件随机场(CRF)是一种统计方法，通过对文本中出现的单词序列的不同特征进行加权来学习模式。这种方法考虑上下文和不同变量之间的关系，以便作出预测。使用条件随机场允许您创建复杂和丰富的模式。这种方法的另一个优点是它的泛化能力:一旦模型用某个领域的例子进行了训练，它就可以很容易地将它所学到的知识应用到其他领域。缺点是，为了使用条件随机场，您需要有很强的计算能力来计算所有单词序列的所有特征的权重。 评估关键字提取器的性能在评估关键字提取器的性能时，您可以使用机器学习中的一些标准指标:准确性、精度、召回率和F1分数。然而，这些指标并不能反映部分匹配;他们只考虑所提取的片段与该标记的正确预测之间的完美匹配。幸运的是，还有一些其他指标能够捕获部分匹配。一个例子就是ROUGE。ROUGE(面向回忆的基sting评价替补研究)是一组比较源文本和提取词之间不同参数(如重叠词的数量)的指标。参数包括序列的长度和数目，可以手动定义。 混合方法 混合之前的方法。"},{"title":"nlp工具总结","date":"2021-01-12T02:44:43.000Z","path":"2021/01/12/nlp工具总结/","text":"NLP工具总结 MonkeyLearn相关解决方案"},{"title":"mysql使用总结","date":"2021-01-12T02:29:10.000Z","path":"2021/01/12/mysql使用总结/","text":"MySQL使用总结"},{"title":"rust使用总结","date":"2021-01-11T15:03:15.000Z","path":"2021/01/11/rust使用总结/","text":"rust使用总结 Rust Report Card - 为你的 Rust 代码生成质量报告 简介： 官网https://rust-reportcard.xuri.me，Rust Report Card 服务，通过近 500 个代码检测项帮助分析你的 Rust 代码中的潜在质量问题，还可获得 badge 徽章。 该服务基于 rust-clippy 中 定义的 lint 规则对 Rust 进行静态代码分析扫描，在 Rust 编译器检查的基础之上帮你更进一步，编写出更好的代码，检查内容涵盖可优化性能写法、可简化代码写法、代码惯用风格更符合最佳实践、未使用变量和 cargo 声明文件检查等。 Rust Report Card 提供了增量代码扫描、代码质量评级、徽章生成、协议检查和内部开源 Rust 代码质量评分排行等功能。 代码质量评级与得分规则： 3+ 评级 得分 Badge A+ &gt; 90 A &gt; 80 B &gt; 70 C &gt; 60 D &gt; 50 E &gt; 40 F &lt;= 40"},{"title":"typescript使用总结","date":"2021-01-11T13:46:51.000Z","path":"2021/01/11/typescript使用总结/","text":"Type Script使用总结 安装typescript sudo apt install npm sudo npm install -g typescript 通过tsc命令确认安装完成 tsc -v 运行ts文件 tsc ***.ts // 得到***.js文件 node ***.js // 使用node命令执行js文件 运行ts文件出现以下错误 Cannot find module &#39;fs&#39; 执行以下命令： sudo npm install @types/node"},{"title":"python使用总结","date":"2021-01-09T14:20:08.000Z","path":"2021/01/09/python使用总结/","text":"python使用总结 python numpy real函数 用法： numpy.real(val) 返回复杂参数的实部。 | 参数： | val**： ： array_like输入数组。 || ———— | —————————————————————————————— || 返回值： | out**： ： ndarray或标量复杂参数的实际组成部分。如果val是实数，则将val的类型用于输出。如果val具有复杂元素，则返回的类型为float。 | 例子： &gt;&gt;&gt; a = np.array([1+2j, 3+4j, 5+6j]) &gt;&gt;&gt; a.real array([1., 3., 5.]) &gt;&gt;&gt; a.real = 9 &gt;&gt;&gt; a array([9.+2.j, 9.+4.j, 9.+6.j]) &gt;&gt;&gt; a.real = np.array([9, 8, 7]) &gt;&gt;&gt; a array([9.+2.j, 8.+4.j, 7.+6.j]) &gt;&gt;&gt; np.real(1 + 1j) 1.0 源码： numpy.real的API实现见：[源代码] python执行ubuntu terminal命令 import os os.system(&#39;&lt;ubuntu 命令&gt;&#39;) 在执行ubuntu terminal命令时，如果需要切换路径： os.chdir(&#39;&lt;路径名称&gt;&#39;)"},{"title":"ubuntu使用总结","date":"2021-01-09T08:21:12.000Z","path":"2021/01/09/ubuntu使用总结/","text":"ubuntu 使用总结 ubuntu查看环境变量有三个命令 1、env env命令是environment的缩zhi写，用dao于列出所zhuan有的环境变量 2、export 单独使用export命令也可以像env列出所有的环境变量，不过export命令还有其他额外的功能 3、echo $PATH echo $PATH用于列出变量PATH的值，里面包含了已添加的目录 ubuntu修改环境变量： 1、使用set命令 set查看所有本地定义的环境变量，unset可以删除指定的环境变量。 2、使用export命令 export &lt;变量名称&gt;=$&lt;变量名称&gt;:&lt;变量值&gt; //等号两边一定不能有空格 3、修改.bashrc文件 vi ~/.bashrc //编辑.bashrc文件 //在最后一行添上: export &lt;变量名称&gt;=$&lt;变量名称&gt;:&lt;变量值&gt; //等号两边没空格 //保存退出 source ~/.bashrc 注意，常用的环境变量： PATH 决定了shell将到哪些目录中寻找命令或程序 HOME 当前用户主目录 HISTSIZE 历史记录数 LOGNAME 当前用户的登录名 HOSTNAME 指主机的名称 SHELL 当前用户Shell类型 LANGUGE 语言相关的环境变量，多语言可以修改此环境变量 MAIL 当前用户的邮件存放目录 PS1 基本提示符，对于root用户是#，对于普通用户是$ ubuntu中&gt;和&gt;&gt;和&lt;的区别 1、输入输出的区bai别： &gt;&gt;和&gt;都属于输出重定向，&lt;属于输入重定向。 2、文件内容的区别： &gt;会覆盖目标的原有内容。当文件存在时会先删除原文件，再重新创建文件，然后把内容写入该文件；否则直接创建文件。 &gt;&gt;会在目标原有内容后追加内容。当文件存在时直接在文件末尾进行内容追加，不会删除原文件；否则直接创建文件。"},{"title":"git使用总结","date":"2021-01-09T08:18:40.000Z","path":"2021/01/09/git使用总结/","text":"git 使用总结 git log --stat的使用 1、显示最近一次被修改文件的修改：统计信息，添加或删除了多少行。 git log -1 --stat 2、显示最近两条的修改 git log --stat -2 3、显示具体的修改 git log -p -2 4、显示用户为czd的修改 git log --stat --author=czd 5、查看单个文件sensor-dev.c最近三次修改的记录 git log --stat -3 drivers/input/sensors/sensor-dev.c 6、如果想不分页输出全部log日志 git --no-pager log 当使用git --no-pager log --stat &gt;&gt; temp.txt出现以下报错信息时： warning: inexact rename detection was skipped due to too many files. warning: you may want to set your diff.renameLimit variable to at least 6567 and retry the command. 修改git的diff.renameLimit变量值 git config diff.renameLimit 2000000 github api使用总结 1、得到某个仓库的贡献者 api.github.com/repos/&lt;项目所属组织或个人&gt;/&lt;项目名称&gt;/contributors 返回的json中contributions即为commit次数。 2、得到某一用户在github上面贡献了多少库 benjycui编写了一个实现该功能的工具。 修改git commit的默认编辑器 进入项目的根目录下，使用vim ./.git/config and add the &quot;editor = vim&quot;或git config --global core.editor vim将默认编辑器从GNA nano修改为vim。 新建一个仓库并和远程仓库连接 1、mkdir new_repo 2、cd new_repo 3、git init 4、在github或gitee上新建一个同名仓库 5、git remote add &lt;remote_repo_name&gt; &lt;remote_repo_address&gt; 分支 1、查看所有分支 git branch 2、选择某个特定的分支 git checkout &lt;branch name&gt; 3、新建一个分支并选定 git checkout -b &lt;branch name&gt;"},{"title":"ubuntu服务器-Nginx初步配置及站点部署","date":"2021-01-08T01:51:13.000Z","path":"2021/01/08/ubuntu服务器-Nginx初步配置及站点部署/","text":"ubuntu服务器-Nginx初步配置及站点部署 使用SSH远程登录服务器 ssh root@***.***.***.*** 安装Nginx并启动服务器 apt update apt install nginx systemctl start nginx 将项目上传到服务器 可以选择本地上传或者 github clone。 编辑默认的default root /var默认路径，并将代码移动至路径下。 cd /etc/nginx/sites-available vim default (rewrite) root /var/www/sites cd /var/www mv &lt;code path&gt; sites 检测nginx配置文件，重启nginx服务器 nginx -t service nginx restart"},{"title":"基于Github和Hexo搭建个人网站","date":"2021-01-06T12:13:18.000Z","path":"2021/01/06/website-based-github-hexo/","text":"基于Github和Hexo搭建个人网站 安装并配置 Git Git 是目前世界上最先进的分布式版本控制系统（没有之一）,使用 Git 的目的是为了将网站从本地提交上服务器（GitHub）上面去。具体的 Git 操作细节可以查看廖雪峰的教程，讲的十分详细。 在终端进行操作，设置 user.name 和 user.email 配置信息，为了方便推荐设置为全局。 git config --global user.name &quot;GitHub账号名称&quot; git config --global user.email &quot;GitHub注册邮箱&quot; ** 通过注册的邮箱生成 ssh 密钥文件： ssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot; 直接三个回车，默认不需要设置密码。最后得到了两个文件： id_rsa 和 id_rsa.pub。打开 id_rsa.pub 文件，将里面的内容全部复制到 Github 上。添加 SSH key 后，进行测试。 ssh -T git@github.com 你将会看到： The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 选择yes后 Hi ***! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 新建一个 Github 仓库，仓库名为：&lt;github账号名称&gt;.github.io 安装Node.js可以根据自己的系统自行搜索安装方法，ubuntu 上的安装方法为：sudo apt-get install nodejs 安装并配置 Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 sudo npm install -g hexo-cli 初始化博客 hexo init myBlog 进入myBlog文件夹中，输入 hexo server 或者hexo s 打开浏览器输入地址：localhost:4000 这样就可以看见博客了。 添加文章(1) 可以将你平时写的文章直接导入到 _posts 文件夹里，注意文章类型得是 md 格式。(2) 可以写新文章，执行以下命令 hexo new [layout] &lt;title&gt; 可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 生成静态网页 hexo generate 或者hexo g 将网页部署到 Github 上Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。在开始之前，必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：deploy: type: git repo: https://github.com/***/***.github.io branch: master 之后输入以下命令：hexo deploy 或者hexo d 稍等片刻，网站就已经部署好了，可以在浏览器输入 ***.github.io，这样一个免费的博客就已经搭建好了。 选择主题Hexo 默认的主题比较一般，可以在Hexo的主题网站进行主题的挑选更换。将下好的主题安放在themes文件夹内，同时在_config.yml中进行主题修改就好了。一般每个主题都会有比较详细的说明文档，按照文档进行修改即可。 Hexo渲染LaTeX公式Hexo渲染主题的两个重要因素：mathjax和kramed，前者是数学公式渲染引擎，后者是Hexo的markdown渲染引擎，hexo默认渲染引擎是marked，但是它不支持mathjax，因此需要替换引擎。 一、Hexo添加mathjax 如果hexo安装有hexo-math,需要先卸载它。卸载命令： npm uninstall hexo-math --save 安装mathjax，安装命令： npm install hexo-renderer-mathjax --save hexo主题开启mathjax： 进入主题目录，编辑_config.yml，开启mathjax： # MathJax Support mathjax: enable: true per_page: true 二、hexo切换kramed引擎 卸载marked引擎 npm uninstall hexo-renderer-marked --save 安装kramed引擎 npm install hexo-renderer-kramed --save 修改引擎bug 修改文件/node_modules\\kramed\\lib\\rules\\inline.js中escape和em两行，具体修改如下： // escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, 这一步是在原基础上取消了对,{,}的转义(escape)。同时把第20行的em变量也要做相应的修改。 进入主题目录，编辑_config.yml，开启mathjax： // em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 重新启动hexo: hexo clean &amp;&amp; hexo g -d"}]