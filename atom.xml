<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CAKGOD</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-25T02:39:37.851Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>CAKGOD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>霍夫曼树</title>
    <link href="http://example.com/2021/02/25/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://example.com/2021/02/25/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91/</id>
    <published>2021-02-25T02:16:55.000Z</published>
    <updated>2021-02-25T02:39:37.851Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="https://www.jianshu.com/p/5ad3e97d54a3">https://www.jianshu.com/p/5ad3e97d54a3</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>霍夫曼树是二叉树的一种特殊形式，又称为最优二叉树，其主要作用在于数据压缩和编码长度的优化。</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="路径和路径长度"><a href="#路径和路径长度" class="headerlink" title="路径和路径长度"></a>路径和路径长度</h3><p>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为<strong>路径</strong>。通路中分支的数目称为<strong>路径长度</strong>。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p><p><img src="https://upload-images.jianshu.io/upload_images/7043118-f75c7a1e99fdf648.png?imageMogr2/auto-orient/strip|imageView2/2/w/340/format/webp" alt=""></p><p>上图所示二叉树结点A到结点D的路径长度为2，结点A到达结点C的路径长度为1。</p><h3 id="结点的权及带权路径长度"><a href="#结点的权及带权路径长度" class="headerlink" title="结点的权及带权路径长度"></a>结点的权及带权路径长度</h3><p>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。下图稀罕事了一棵带权的二叉树。</p><p><img src="https://upload-images.jianshu.io/upload_images/7043118-6091540162f48e8c.png?imageMogr2/auto-orient/strip|imageView2/2/w/357/format/webp" alt=""></p><h3 id="树的带权路径长度"><a href="#树的带权路径长度" class="headerlink" title="树的带权路径长度"></a>树的带权路径长度</h3><p>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为<code>WPL</code>。<br>上图所示二叉树的<code>WPL</code>：<br><code>WPL = 6 * 2 + 3 * 2 + 8 * 2 = 34</code>；</p><h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为霍夫曼树(Huffman Tree)。如下图所示两棵二叉树。</p><p><img src="https://upload-images.jianshu.io/upload_images/7043118-60c5f01992b15153.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp" alt=""></p><p>叶子结点为A、B、C、D，对应权值分别为7、5、2、4。3.1.a树的<code>WPL = 7 * 2 + 5 * 2 + 2 * 2 + 4 * 2 = 36</code>，<code>3.1.b树的WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3 = 35</code>。由ABCD构成叶子结点的二叉树形态有许多种，但是<code>WPL</code>最小的树只有3.1.b所示的形态。则3.1.b树为一棵霍夫曼树。</p><h3 id="构造霍夫曼树"><a href="#构造霍夫曼树" class="headerlink" title="构造霍夫曼树"></a>构造霍夫曼树</h3><p>构造霍夫曼树主要运用于编码，称为霍夫曼编码。现考虑使用3.1中ABCD结点以及对应的权值构成如下长度编码。<code>AACBCAADDBBADDAABB</code>。编码规则为：从根节点出发，向左标记为0，向右标记为1。采用上述编码规则，将上图编码为下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/7043118-1c37046c5ee37372.png?imageMogr2/auto-orient/strip|imageView2/2/w/545/format/webp" alt=""></p><p>构造过程：3.1.a所示二叉树称为等长编码，由于共有4个结点，故需要2位编码来表示，编码结果为：</p><div class="table-container"><table><thead><tr><th>结点</th><th>编码</th></tr></thead><tbody><tr><td>A</td><td>00</td></tr><tr><td>B</td><td>01</td></tr><tr><td>C</td><td>10</td></tr><tr><td>D</td><td>11</td></tr></tbody></table></div><p>则<code>AACBCAADDBBADDAABB</code>对应编码为：<code>00 00 10 01 10 00 00 11 11 01 01 00 11 11 00 00 01 01</code>，长度为36。</p><p>3.1.b构造过程如下：<br>1）选择结点权值最小的两个结点构成一棵二叉树如图3.3：</p><p><img src="https://upload-images.jianshu.io/upload_images/7043118-4ba1c6c17cd49fc1.png?imageMogr2/auto-orient/strip|imageView2/2/w/223/format/webp" alt=""></p><p>2）则现在可以看作由T1，A，B构造霍夫曼树，继续执行步骤1。<br>选则B和T1构成一棵二叉树如图3.4：</p><p><img src="https://upload-images.jianshu.io/upload_images/7043118-3a2ec3c6a7495042.png?imageMogr2/auto-orient/strip|imageView2/2/w/254/format/webp" alt=""></p><p>3）现只有T2和A两个结点，继续执行步骤1。<br>选择A和T2构成一棵二叉树如图3.5：</p><p><img src="https://upload-images.jianshu.io/upload_images/7043118-fb3a3e0c62c27d84.png?imageMogr2/auto-orient/strip|imageView2/2/w/379/format/webp" alt=""></p><p>经过上述步骤则可以构造完一棵霍夫曼树。通过观察可以发现，霍夫曼树中权值越大的结点距离根结点越近。<br>按照图3.5霍夫曼树编码结果：</p><div class="table-container"><table><thead><tr><th>结点</th><th>编码</th></tr></thead><tbody><tr><td>A</td><td>0</td></tr><tr><td>B</td><td>10</td></tr><tr><td>C</td><td>110</td></tr><tr><td>D</td><td>111</td></tr></tbody></table></div><p>则<code>AACBCAADDBBADDAABB</code>对应编码为：<code>0 0 110 10 110 0 0 111 111 10 10 0 111 111 0 0 10 10</code>，编码长度为35。由此可见，采用二叉树可以适当降低编码长度，尤其是在编码长度较长，且权值分布不均匀时，采用霍夫曼编码可以大大缩短编码长度。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>后续补充</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自&lt;a href=&quot;https://www.jianshu.com/p/5ad3e97d54a3&quot;&gt;https://www.jianshu.com/p/5ad3e97d54a3&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;heade</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用meilisearch搭建rust搜索引擎</title>
    <link href="http://example.com/2021/02/24/%E4%BD%BF%E7%94%A8meilisearch%E6%90%AD%E5%BB%BArust%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    <id>http://example.com/2021/02/24/%E4%BD%BF%E7%94%A8meilisearch%E6%90%AD%E5%BB%BArust%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</id>
    <published>2021-02-24T12:27:37.000Z</published>
    <updated>2021-02-24T13:02:27.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>meilissearch和Elasticsearch的主要区别是什么?为什么它们很重要?<br>自2010年创建以来，Elasticsearch迅速成为搜索引擎市场的热门选项，在各种应用程序和数据集中都有使用。然而，不可否认的是，对于繁重的全文搜索来说，它是一个强大的工具，但在使用之前需要进行广泛的配置，这意味着所有这些功能都伴随着高昂的资源成本。<br>对于处理大量日志的大型科技公司来说，Elasticsearch可能是有意义的。但对于中等规模的数据集(即少于500万行)和较小的应用程序，它就不适合这份工作。尽管如此，由于历史上没有开源的替代方案，开发人员仍然选择弹性作为他们的默认解决方案，最终在设置和培训上损失了不成比例的大量时间。<br>这就是“Meilisearch”的用武之地。MeiliSearch提供了一个快速、相关和容错的搜索，并且几乎不需要设置时间，对于任何需要一个强大且可访问的搜索引擎的开发人员来说，它都是一个很好的解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;meilissearch和Elasticsearch的主要区别是什么?为什么它们很重要?&lt;br&gt;自2010年创建以来，Elasticsear</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>zulip聊天记录爬取</title>
    <link href="http://example.com/2021/02/24/zulip%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E7%88%AC%E5%8F%96/"/>
    <id>http://example.com/2021/02/24/zulip%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E7%88%AC%E5%8F%96/</id>
    <published>2021-02-24T10:43:23.000Z</published>
    <updated>2021-02-24T11:17:56.170Z</updated>
    
    <content type="html"><![CDATA[<p>出于团队rust洞察任务需求，需要研发出zulip聊天记录抓取和提取工具。我的系统是ubuntu20，按照网上的教程搜索安装zulip，注意配置rc文件即可。</p><p>接下来需要导出zulip的聊天记录。以rust治理组的zulip聊天室为例，首先设定一个channel列表，代表不同的聊天频道。</p><p>接下来调用python的zulip包，首先调用<code>zulip.client(config_file)</code>，之后调用client.get_messages(request)来获得返回值。这里request中可以修改获取聊天记录的数量和起止时间。将这些聊天记录根据聊天室名称分别保存。</p><p>将聊天记录保存为文件之后，根据词匹配、切分等方法，将信息提取为“发送者姓名”，“发送者邮箱”，“时间”，“主题”，“内容”五个维度，并将其存入json文件中。</p><p>整体下来，获取过程还是比较简单的。由于zulip python库的存在，我们不需要另外去请求连接了。信息获取下来之后，可以使用关键词提取等方法，获取聊天记录热词等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;出于团队rust洞察任务需求，需要研发出zulip聊天记录抓取和提取工具。我的系统是ubuntu20，按照网上的教程搜索安装zulip，注意配置rc文件即可。&lt;/p&gt;
&lt;p&gt;接下来需要导出zulip的聊天记录。以rust治理组的zulip聊天室为例，首先设定一个channe</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>github项目信息提取</title>
    <link href="http://example.com/2021/02/24/github%E9%A1%B9%E7%9B%AE%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/"/>
    <id>http://example.com/2021/02/24/github%E9%A1%B9%E7%9B%AE%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/</id>
    <published>2021-02-24T08:18:13.000Z</published>
    <updated>2021-02-24T08:47:05.326Z</updated>
    
    <content type="html"><![CDATA[<p>之前对Github用户主页进行了信息提取，这次对Github项目信息进行提取。由于项目的特殊性，不仅存在基本信息，也存在贡献者、commit等信息。这些信息如果通过url访问将是非常巨大的工作量，因此可以采用将仓库克隆到本地使用git解析的方法来进行这类信息的提取。综上，对于一个项目的信息提取包括以下步骤。</p><ul><li>访问仓库网页地址，例如<a href="https://github.com/rust-lang/rust，并使用BeautifulSoup对返回的网页进行解析。">https://github.com/rust-lang/rust，并使用BeautifulSoup对返回的网页进行解析。</a></li><li>将仓库使用<code>git clone</code>命令保存到本地，然后使用<code>git --no-pager log --stat &gt;&gt; commit_file.txt</code>命令保存commit记录，然后从这个文件中提取贡献者和具体的贡献记录。</li></ul><p>解析网页的内容相对比较简单，使用BeautifulSoup提取标签内容、标签属性等即可，跟之前提取用户主页信息类似。</p><p>解析commit信息相对复杂一些，需要使用关键词筛选和正则匹配等方法，将包含commit信息的行提取出来，并根据不同的贡献者、不同的文件路径（注意不仅仅是文件名，要更高级一点）分别统计总体的代码贡献行数。这里有个有趣的发现，commit信息中包含了非常重要的开发者联系方式，即邮箱，这个可是在外面难以搜索到的。emmmmmm。。。</p><p>最终将所有的信息存储到project字典中，一级字段包括summary、contributors、file_commits。该dict可以另存为json文件，方便进行其他操作。具体的代码见<a href="https://github.com/CAKGOD/myCode/blob/master/examples/github/github_project_homepage_extraction.ipynb。">https://github.com/CAKGOD/myCode/blob/master/examples/github/github_project_homepage_extraction.ipynb。</a></p><p>本次Github项目信息提取的效果还是不错的，不过还是有一些可以改进的地方。例如可以添加根据时间进行统计的功能，毕竟有时候我们只是想统计最近一段时间的贡献历史。这个项目信息统计出来之后，可以用来找出关键贡献者（例如使用半衰期排名算法，明后天更新一下）、关键代码文件等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前对Github用户主页进行了信息提取，这次对Github项目信息进行提取。由于项目的特殊性，不仅存在基本信息，也存在贡献者、commit等信息。这些信息如果通过url访问将是非常巨大的工作量，因此可以采用将仓库克隆到本地使用git解析的方法来进行这类信息的提取。综上，对</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>github用户主页信息提取</title>
    <link href="http://example.com/2021/02/23/github%E7%94%A8%E6%88%B7%E4%B8%BB%E9%A1%B5%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/"/>
    <id>http://example.com/2021/02/23/github%E7%94%A8%E6%88%B7%E4%B8%BB%E9%A1%B5%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/</id>
    <published>2021-02-23T14:10:17.000Z</published>
    <updated>2021-02-23T14:34:44.882Z</updated>
    
    <content type="html"><![CDATA[<p>Github真的是一个非常好的网站。从Github的用户个人主页可以看到用户公开的信息，也可以体现出用户的技术栈、兴趣爱好、最近的动态等等。为了完整地对一个用户进行画像，需要有完整的数据来进行支撑，这就需要对Github的个人主页进行信息提取。本次我仅仅解析了个人的主页部分，就是一打开某个人的Github的那个页面。</p><p>Github提供了相应的api可以访问用户的一些信息，但是本次使用了BeautifulSoup来进行解析。首先使用requests模块访问Github主页，这里有一个注意点，如果只是想获得用户的基本信息，直接访问url：<a href="https://github.com/CAKGOD；如果需要获取用户的Activity例如pr、commit等信息，需要访问url：https://github.com/CAKGOD?tab=overview&amp;from=2019-12-01&amp;to=2019-12-31，其中的日期根据自己的需要进行修改。例如我想根据某个用户的月度贡献来进行统计，就把上面from和to的值间隔改成一个月。">https://github.com/CAKGOD；如果需要获取用户的Activity例如pr、commit等信息，需要访问url：https://github.com/CAKGOD?tab=overview&amp;from=2019-12-01&amp;to=2019-12-31，其中的日期根据自己的需要进行修改。例如我想根据某个用户的月度贡献来进行统计，就把上面from和to的值间隔改成一个月。</a></p><p>获得request的返回网页后，使用BeautifulSoup进行解析，其中涉及到一些标签选择、属性值抽取的操作，这些操作按照自己的需求和BeautifulSoup使用文档操作即可。最终我将整个页面归纳为一个dict，其中第一层key为basic和activity，其中basic的二层key有ava、name、id、slogan、followers、following、star、worksFor、homeLocation、email、url、twitter、highlight、Organizations、Sponsoring、pin_popular，Activity的二层key根据月份来对五种活动进行统计。</p><p>具体的代码见<a href="https://github.com/CAKGOD/myCode/blob/master/examples/github/github_homepage_extract.ipynb">https://github.com/CAKGOD/myCode/blob/master/examples/github/github_homepage_extract.ipynb</a></p><p>这次的解析效果还是不错的，不过还是有一些不足之处。例如基本信息的统计维度不完整，用户Activity的类型种类不完整，pinned的项目的语言、star数量、fork数量没有提取。不过这些可以后续完善。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Github真的是一个非常好的网站。从Github的用户个人主页可以看到用户公开的信息，也可以体现出用户的技术栈、兴趣爱好、最近的动态等等。为了完整地对一个用户进行画像，需要有完整的数据来进行支撑，这就需要对Github的个人主页进行信息提取。本次我仅仅解析了个人的主页部分</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>javascript使用总结</title>
    <link href="http://example.com/2021/02/08/javascript%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/02/08/javascript%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-08T07:08:20.000Z</published>
    <updated>2021-02-08T13:13:09.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript使用总结"><a href="#JavaScript使用总结" class="headerlink" title="JavaScript使用总结"></a>JavaScript使用总结</h1><h2 id="‘use-strict’"><a href="#‘use-strict’" class="headerlink" title="‘use strict’"></a>‘use strict’</h2><p>“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。”use strict” 的目的是指定代码在严格条件下执行。严格模式下你不能使用未声明的变量。</p><p>使用严格模式的优势可以消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为；</p><ul><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。</li></ul><p>“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>setTimeout() 是属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式。语法格式可以是以下两种：</p><pre><code class="lang-javascript">setTimeout(要执行的代码, 等待的毫秒数)setTimeout(JavaScript 函数, 等待的毫秒数)</code></pre><p>setTimeout() 是设定一个指定等候时间（单位是千分之一秒，millisecond）, 时间到了，浏览器就会执行一个指定的代码。</p><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p>var 语句用于声明变量。JavaScript变量的创建也叫作“声明“一变量：</p><pre><code>var carName;</code></pre><p>变量声明后，变量为空 (没有值)。为变量赋值，操作如下:</p><pre><code>carName = &quot;Volvo&quot;;</code></pre><p>声明变量时，你同样可以为变量赋值：</p><pre><code>var carName = &quot;Volvo&quot;;</code></pre><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>所有浏览器都支持 window 对象，它表示浏览器窗口。所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p><p>全局变量是 window 对象的属性。全局函数是 window 对象的方法。甚至 HTML DOM 的 document 也是 window 对象的属性之一：</p><pre><code>window.document.getElementById(&quot;header&quot;);</code></pre><p>与此相同：</p><pre><code>document.getElementById(&quot;header&quot;);</code></pre><h3 id="window尺寸"><a href="#window尺寸" class="headerlink" title="window尺寸"></a>window尺寸</h3><p>有三种方法能够确定浏览器窗口的尺寸。对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：</p><ul><li><code>window.innerHeight</code> - 浏览器窗口的内部高度(包括滚动条)</li><li><code>window.innerWidth</code> - 浏览器窗口的内部宽度(包括滚动条)</li></ul><p>对于 Internet Explorer 8、7、6、5：</p><ul><li><code>document.documentElement.clientHeight</code></li><li><p><code>document.documentElement.clientWidth</code><br>或者</p></li><li><p><code>document.body.clientHeight</code></p></li><li><code>document.body.clientWidth</code></li></ul><h3 id="其他window方法"><a href="#其他window方法" class="headerlink" title="其他window方法"></a>其他window方法</h3><ul><li><code>window.open()</code> - 打开新窗口</li><li><code>window.close()</code> - 关闭当前窗口</li><li><code>window.moveTo()</code> - 移动当前窗口</li><li><code>window.resizeTo()</code> - 调整当前窗口的尺寸</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript使用总结&quot;&gt;&lt;a href=&quot;#JavaScript使用总结&quot; class=&quot;headerlink&quot; title=&quot;JavaScript使用总结&quot;&gt;&lt;/a&gt;JavaScript使用总结&lt;/h1&gt;&lt;h2 id=&quot;‘use-strict’&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>github-api使用总结</title>
    <link href="http://example.com/2021/02/05/github-api%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/02/05/github-api%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-05T11:42:33.000Z</published>
    <updated>2021-02-05T12:00:31.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github-api使用总结"><a href="#github-api使用总结" class="headerlink" title="github-api使用总结"></a>github-api使用总结</h1><ul><li><p>github search api</p><ol><li><p>找到过去一段时间内最热的几个项目</p><pre><code class="lang-curl">$ curl -G https://api.github.com/search/repositories       \    --data-urlencode &quot;q=created:2021-01-01&quot; \    --data-urlencode &quot;sort=stars&quot;                          \    --data-urlencode &quot;order=desc&quot;                          \    -H &quot;Accept: application/vnd.github.preview&quot;            \    | jq &quot;.items[0,1,2] | &#123;name, description, language, watchers_count, html_url&#125;&quot;</code></pre></li><li><p>找到最早的用户账号并且没有人follow的github账号（人类清除计划hhh）</p><pre><code>$ curl -G https://api.github.com/search/users   \    --data-urlencode &#39;q=followers:0&#39;            \    --data-urlencode &#39;sort=joined&#39;              \    --data-urlencode &#39;order=asc&#39;                \    -H &#39;Accept: application/vnd.github.preview&#39; \    | jq &#39;.items[0,1,2] | &#123;html_url, login, id&#125;&#39;</code></pre></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;github-api使用总结&quot;&gt;&lt;a href=&quot;#github-api使用总结&quot; class=&quot;headerlink&quot; title=&quot;github-api使用总结&quot;&gt;&lt;/a&gt;github-api使用总结&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;github search</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>markdown使用总结</title>
    <link href="http://example.com/2021/02/04/markdown%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/02/04/markdown%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-04T02:48:26.000Z</published>
    <updated>2021-02-04T02:48:50.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown使用教程"><a href="#Markdown使用教程" class="headerlink" title="Markdown使用教程"></a>Markdown使用教程</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><h2 id="2、Markdown标题"><a href="#2、Markdown标题" class="headerlink" title="2、Markdown标题"></a>2、Markdown标题</h2><p>Markdown 标题有两种格式。</p><h3 id="（1）使用-和-标记一级和二级标题"><a href="#（1）使用-和-标记一级和二级标题" class="headerlink" title="（1）使用 = 和 - 标记一级和二级标题"></a>（1）使用 = 和 - 标记一级和二级标题</h3><p>= 和 - 标记语法格式如下：</p><pre><code>我展示的是一级标题=================我展示的是二级标题-----------------</code></pre><h3 id="（2）使用-号标记"><a href="#（2）使用-号标记" class="headerlink" title="（2）使用 # 号标记"></a>（2）使用 # 号标记</h3><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h2 id="3、Markdown-段落"><a href="#3、Markdown-段落" class="headerlink" title="3、Markdown 段落"></a>3、Markdown 段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。  </p><p>当然也可以在段落后面使用一个空行来表示重新开始一个段落。</p><h2 id="4、Markdown字体"><a href="#4、Markdown字体" class="headerlink" title="4、Markdown字体"></a>4、Markdown字体</h2><p>Markdown 可以使用以下几种字体：</p><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><h2 id="5、Markdown分割线"><a href="#5、Markdown分割线" class="headerlink" title="5、Markdown分割线"></a>5、Markdown分割线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code>**** * ******- - -----------</code></pre><h2 id="6、Markdown删除线"><a href="#6、Markdown删除线" class="headerlink" title="6、Markdown删除线"></a>6、Markdown删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可，实例如下：</p><pre><code>RUNOOB.COMGOOGLE.COM~~BAIDU.COM~~</code></pre><h2 id="7、Markdown下划线"><a href="#7、Markdown下划线" class="headerlink" title="7、Markdown下划线"></a>7、Markdown下划线</h2><p>下划线可以通过 HTML 的 <u> 标签来实现：</p><pre><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><h2 id="8、Markdown脚注"><a href="#8、Markdown脚注" class="headerlink" title="8、Markdown脚注"></a>8、Markdown脚注</h2><p>脚注是对文本的补充说明。</p><p>Markdown 脚注的格式如下:</p><pre><code>[^要注明的文本]</code></pre><p>以下实例演示了脚注的用法：</p><pre><code>创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</code></pre><h2 id="9、Markdown列表"><a href="#9、Markdown列表" class="headerlink" title="9、Markdown列表"></a>9、Markdown列表</h2><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>有序列表使用数字并加上 <strong>.</strong> 号来表示，如：</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><h2 id="10、Markdown区块"><a href="#10、Markdown区块" class="headerlink" title="10、Markdown区块"></a>10、Markdown区块</h2><p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><pre><code>&gt; 区块引用&gt; 菜鸟教程&gt; 学的不仅是技术更是梦想</code></pre><p>另外区块是可以嵌套的，一个 <strong>&gt;</strong> 符号是最外层，两个 <strong>&gt;</strong> 符号是第一层嵌套，以此类推：</p><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><p>区块中使用列表实例如下：</p><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><p>如果要在列表项目内放进区块，那么就需要在 <strong>&gt;</strong> 前添加四个空格的缩进。</p><p>区块中使用列表实例如下：</p><pre><code>* 第一项    &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想* 第二项</code></pre><h2 id="11、Markdown代码"><a href="#11、Markdown代码" class="headerlink" title="11、Markdown代码"></a>11、Markdown代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（<strong>`</strong>），例如：</p><pre><code>`printf()` 函数</code></pre><p>代码区块使用 <strong>4 个空格</strong>或者一个<strong>制表符（Tab 键）</strong>。  </p><p>也可以用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p><pre><code>​```javascript$(document).ready(function () &#123;    alert(&#39;RUNOOB&#39;);&#125;);​</code></pre><pre><code>## 12、Markdown链接链接使用方法如下：</code></pre><p><a href="链接地址">链接名称</a></p><p>或者</p><p>&lt;链接地址&gt;</p><pre><code>例如：</code></pre><p>这是一个链接 <a href="https://www.runoob.com">菜鸟教程</a></p><pre><code>可以通过变量来设置一个链接，变量赋值在文档末尾进行：</code></pre><p>这个链接用 1 作为网址变量 <a href="http://static.runoob.com/images/runoob-logo.png">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><pre><code>## 13、Markdown图片Markdown 图片语法格式如下：</code></pre><p><img src="图片地址" alt="alt 属性文本"></p><p><img src="图片地址" alt="alt 属性文本" title="可选标题"></p><pre><code>- 开头一个感叹号 !- 接着一个方括号，里面放上图片的替代文字- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 &#39;title&#39; 属性的文字。  使用示例：</code></pre><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><pre><code>当然，也可以像网址那样对图片网址使用变量:.</code></pre><p>这个链接用 1 作为网址变量 <a href="http://static.runoob.com/images/runoob-logo.png">RUNOOB</a>.<br>然后在文档的结尾为变量赋值（网址）</p><pre><code>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。</code></pre><p><img src="http://static.runoob.com/images/runoob-logo.png" width="50%"></p><pre><code>## 14、Markdown表格Markdown 制作表格使用 **|** 来分隔不同的单元格，使用 **-** 来分隔表头和其他行。语法格式如下：</code></pre><div class="table-container"><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table></div><pre><code>**可以设置表格的对齐方式：**- **-:** 设置内容和标题栏居右对齐。- **:-** 设置内容和标题栏居左对齐。- **:-:** 设置内容和标题栏居中对齐。示例如下：</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table></div><pre><code>## 15、Markdown 高级技巧不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：`&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;`等 ，如：</code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><pre><code>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</code></pre><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><pre><code>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</code></pre><p>\   反斜线<br>`   反引号</p><ul><li>星号<br>_   下划线<br>{}  花括号<br>[]  方括号<br>()  小括号<h1 id="井字号"><a href="#井字号" class="headerlink" title="井字号"></a>井字号</h1></li></ul><ul><li>加号</li></ul><ul><li>减号<br>.   英文句点<br>!   感叹号<br>```</li></ul><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><pre><code>$$\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125; \mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\\end&#123;vmatrix&#125;$&#123;$tep1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown使用教程&quot;&gt;&lt;a href=&quot;#Markdown使用教程&quot; class=&quot;headerlink&quot; title=&quot;Markdown使用教程&quot;&gt;&lt;/a&gt;Markdown使用教程&lt;/h1&gt;&lt;h2 id=&quot;1、简介&quot;&gt;&lt;a href=&quot;#1、简介&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用turtlebot2和速腾聚创雷达搭建移动机器人数据采集平台</title>
    <link href="http://example.com/2021/02/04/%E4%BD%BF%E7%94%A8turtlebot2%E5%92%8C%E9%80%9F%E8%85%BE%E8%81%9A%E5%88%9B%E9%9B%B7%E8%BE%BE%E6%90%AD%E5%BB%BA%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%B9%B3%E5%8F%B0/"/>
    <id>http://example.com/2021/02/04/%E4%BD%BF%E7%94%A8turtlebot2%E5%92%8C%E9%80%9F%E8%85%BE%E8%81%9A%E5%88%9B%E9%9B%B7%E8%BE%BE%E6%90%AD%E5%BB%BA%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%B9%B3%E5%8F%B0/</id>
    <published>2021-02-04T01:47:46.000Z</published>
    <updated>2021-02-04T02:46:22.521Z</updated>
    
    <content type="html"><![CDATA[<p>之前一段时间在Navigation2社区进行贡献，鉴于目前通用的数据集是用于自动驾驶的，社区Leader Steve对移动机器人数据集提出了需求，同时提出了需要考虑到多数开发者控制成本的要求。为此，特意购置了速腾聚创的16线雷达，以及Turtlebot2移动机器人来组装该平台。</p><h2 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h2><p>整套设备由速腾聚创雷达、Xsens惯导、Turtlebot2、Mini PC以及两块电源组成。为了保证雷达有足够的视野，需要将雷达安装在Turtlebot2的最顶部，将电源通过转接器进行电压转化对雷达进行供电。Xsens固定在雷达垂直的位置上，保证相对位置固定，通过Mini PC的数据线连接供电。Mini PC通过同样电源的方法进行供电，并通过网线和雷达连接，通过数据线和Turtlebot连接。Turtlebot本身充满电即可。最后的组装的完整设备如下图所示。</p><h2 id="软件部分"><a href="#软件部分" class="headerlink" title="软件部分"></a>软件部分</h2><ul><li><p>在Mini PC上安装相关软件</p><ol><li><p>安装ubuntu 18.04</p></li><li><p>安装ROS melodic</p></li><li><p>安装Turtlebot相关软件<br><code>sudo apt install ros-melodic-kobuki-*</code><br><code>sudo apt install ros-melodic-ecl-streams</code><br><code>sudo apt install libusb-dev</code><br><code>sudo apt install libspnav-dev</code><br><code>sudo apt install ros-melodic-joystick-drivers</code><br><code>sudo apt install libbluetooth-dev</code><br><code>sudo apt install libcwiid-dev</code><br><code>sudo apt install ros-melodic-robot-pose-ekf</code></p></li><li><p>准备SDK软件<br><code>mkdir -p ~/turtlebot_ws/src</code><br><code>cd ~/turtlebot_ws/src</code><br><code>git clone https://github.com/turtlebot/turtlebot_simulator</code><br><code>git clone https://github.com/turtlebot/turtlebot.git</code><br>​<code>git clone https://github.com/turtlebot/turtlebot_apps.git</code><br><code>git clone https://github.com/udacity/robot_pose_ekf</code><br>​<code>git clone https://github.com/ros-perception/depthimage_to_laserscan.git</code><br><code>git clone https://github.com/yujinrobot/kobuki_msgs.git</code><br><code>git clone https://github.com/yujinrobot/kobuki_desktop.git</code><br><code>cd kobuki_desktop/</code><br>​<code>rm -r kobuki_qtestsuite</code><br><code>git clone https://github.com/toeklk/orocos-bayesian-filtering.git</code><br><code>git clone https://github.com/turtlebot/turtlebot_msgs.git</code><br><code>git clone https://github.com/ros-drivers/joystick_drivers.git</code></p></li><li><p>将<code>kobuki</code>和<code>yujin_ocs</code>依赖复制到<code>turtlebot/src/</code><br>​<code>mkdir -p ~/repos/</code><br><code>cd ~/repos/</code><br>​<code>git clone https://github.com/yujinrobot/kobuki.git</code><br>​<code>cp -r kobuki/* ~/turtlebot_ws/src/</code><br>​<code>git clone https://github.com/yujinrobot/yujin_ocs.git</code><br>​<code>cp -r yujin_ocs/yocs_cmd_vel_mux/ yujin_ocs/yocs_controllers ~/turtlebot_ws/src/</code></p></li><li><p>编译</p><p><code>cd ~/turtlebot_ws</code><br><code>source /opt/ros/melodic/setup.bash</code><br><code>catkin_make</code></p></li><li><p>将工作空间添加到bashrc文件中<br><code>echo &quot;source ~/turtlebot_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p></li><li><p>source </p><p><code>`source ~/.bashrc</code></p></li><li><p>安装Xsens惯导软件</p><p>首先安装mti670驱动，从MT SDK文件夹中将 xsens_ros_mti_driver文件夹复制到catkin工作目录的src文件夹中，使用<code>chmod 777</code>命令对所有文件夹和文件添加权限，然后使用<code>pushd src/xsens_ros_mti_driver/lib/xspublic &amp;&amp; make &amp;&amp; popd</code>命令编译xspublic，最后使用<code>catkin_make</code>编译Mti驱动文件夹。</p></li><li><p>其他</p></li></ol></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>将各个线连接好</p></li><li><p>启动Turtlebot2</p><p><code>roslaunch turtlebot_bringup minimal.launch</code></p><p>将会看以下信息</p><pre><code>ubuntu@AiROS-XA:~/turtlebot_ws/src$ roslaunch turtlebot_bringup minimal.launch      ... logging to /home/ubuntu/.ros/log/a22c211a-7888-11e9-8396-00044bcb943f/roslaunch-AiROS-    XA-6402.log     Checking log directory for disk usage. This may take awhile.     Press Ctrl-C to interrupt     Done checking log file disk usage. Usage is &lt;1GB.     xacro: in-order processing became default in ROS Melodic. You can drop the option.     started roslaunch server http://AiROS-XA:41151/     SUMMARY    ========    PARAMETERS     * /bumper2pointcloud/pointcloud_radius: 0.24     * /cmd_vel_mux/yaml_cfg_file: /home/ubuntu/turt...     * /diagnostic_aggregator/analyzers/input_ports/contains: [&#39;Digital Input&#39;,...     * /diagnostic_aggregator/analyzers/input_ports/path: Input Ports     * /diagnostic_aggregator/analyzers/input_ports/remove_prefix: mobile_base_nodel...     * /diagnostic_aggregator/analyzers/input_ports/timeout: 5.0     * /diagnostic_aggregator/analyzers/input_ports/type: diagnostic_aggreg...     * /diagnostic_aggregator/analyzers/kobuki/contains: [&#39;Watchdog&#39;, &#39;Mot...     * /diagnostic_aggregator/analyzers/kobuki/path: Kobuki     * /diagnostic_aggregator/analyzers/kobuki/remove_prefix: mobile_base_nodel...     * /diagnostic_aggregator/analyzers/kobuki/timeout: 5.0     * /diagnostic_aggregator/analyzers/kobuki/type: diagnostic_aggreg...     * /diagnostic_aggregator/analyzers/power/contains: [&#39;Battery&#39;, &#39;Lapt...     * /diagnostic_aggregator/analyzers/power/path: Power System     * /diagnostic_aggregator/analyzers/power/remove_prefix: mobile_base_nodel...     * /diagnostic_aggregator/analyzers/power/timeout: 5.0     * /diagnostic_aggregator/analyzers/power/type: diagnostic_aggreg...     * /diagnostic_aggregator/analyzers/sensors/contains: [&#39;Cliff Sensor&#39;, ...     * /diagnostic_aggregator/analyzers/sensors/path: Sensors     * /diagnostic_aggregator/analyzers/sensors/remove_prefix: mobile_base_nodel...     * /diagnostic_aggregator/analyzers/sensors/timeout: 5.0     * /diagnostic_aggregator/analyzers/sensors/type: diagnostic_aggreg...     * /diagnostic_aggregator/base_path:      * /diagnostic_aggregator/pub_rate: 1.0     * /mobile_base/base_frame: base_footprint     * /mobile_base/battery_capacity: 16.5     * /mobile_base/battery_dangerous: 13.2     * /mobile_base/battery_low: 14.0     * /mobile_base/cmd_vel_timeout: 0.6     * /mobile_base/device_port: /dev/kobuki     * /mobile_base/odom_frame: odom     * /mobile_base/publish_tf: True     * /mobile_base/use_imu_heading: True     * /mobile_base/wheel_left_joint_name: wheel_left_joint     * /mobile_base/wheel_right_joint_name: wheel_right_joint     * /robot/name: turtlebot     * /robot/type: turtlebot     * /robot_description: &lt;?xml version=&quot;1....     * /robot_state_publisher/publish_frequency: 5.0     * /rosdistro: melodic     * /rosversion: 1.14.3     * /use_sim_time: False    NODES      /        bumper2pointcloud (nodelet/nodelet)        cmd_vel_mux (nodelet/nodelet)        diagnostic_aggregator (diagnostic_aggregator/aggregator_node)        mobile_base (nodelet/nodelet)        mobile_base_nodelet_manager (nodelet/nodelet)        robot_state_publisher (robot_state_publisher/robot_state_publisher)    auto-starting new master    process[master]: started with pid [6415]    ROS_MASTER_URI=http://localhost:11311    setting /run_id to a22c211a-7888-11e9-8396-00044bcb943f    process[rosout-1]: started with pid [6426]    started core service [/rosout]    process[robot_state_publisher-2]: started with pid [6434]    process[diagnostic_aggregator-3]: started with pid [6435]    process[mobile_base_nodelet_manager-4]: started with pid [6440]    process[mobile_base-5]: started with pid [6444]    process[bumper2pointcloud-6]: started with pid [6448]    process[cmd_vel_mux-7]: started with pid [6451]</code></pre></li><li><p>启动键盘控制</p><p>运行<code>$roslaunch turtlebot_teleop keyboard_teleop.launch</code>，屏幕上会出现以下信息：</p><pre><code>    ubuntu@AiROS-XA:~$ roslaunch turtlebot_teleop keyboard_teleop.launch    ... logging to /home/ubuntu/.ros/log/a22c211a-7888-11e9-8396-00044bcb943f/roslaunch-AiROS-XA-6533.log    Checking log directory for disk usage. This may take awhile.    Press Ctrl-C to interrupt    Done checking log file disk usage. Usage is &lt;1GB.    started roslaunch server http://AiROS-XA:41229/    SUMMARY    ========    PARAMETERS     * /rosdistro: melodic     * /rosversion: 1.14.3     * /turtlebot_teleop_keyboard/scale_angular: 1.5     * /turtlebot_teleop_keyboard/scale_linear: 0.5    NODES      /        turtlebot_teleop_keyboard (turtlebot_teleop/turtlebot_teleop_key)    ROS_MASTER_URI=http://localhost:11311    process[turtlebot_teleop_keyboard-1]: started with pid [6552]    Control Your Turtlebot!    ---------------------------    Moving around:       u    i    o       j    k    l       m    ,    .    q/z : increase/decrease max speeds by 10%    w/x : increase/decrease only linear speed by 10%    e/c : increase/decrease only angular speed by 10%    space key, k : force stop    anything else : stop smoothly    CTRL-C to quit    currently:  speed 0.2   turn 1</code></pre></li><li><p>启动雷达</p><p>通过<code>$roslaunch rslidar_pointcloud rs_lidar_32.launch</code>启动雷达和Rviz并且此时可以再Rviz中看到点云。</p></li><li><p>启动Xsens惯导</p><p><code>roslaunch xsens_mti_driver xsens_mti_node.launch</code></p><p>此时可以接收到雷达和IMU的topic了，使用<code>rosbag record ***.bag &lt;topic名字&gt;</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前一段时间在Navigation2社区进行贡献，鉴于目前通用的数据集是用于自动驾驶的，社区Leader Steve对移动机器人数据集提出了需求，同时提出了需要考虑到多数开发者控制成本的要求。为此，特意购置了速腾聚创的16线雷达，以及Turtlebot2移动机器人来组装该平</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vim使用总结</title>
    <link href="http://example.com/2021/02/04/vim%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/02/04/vim%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-04T01:43:39.000Z</published>
    <updated>2021-02-04T01:44:00.150Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>在vim中多开窗口并切换</p><p>(1) use <code>:sp</code> or <code>:vs</code> to split the windows<br>(2) press the <code>ctrl+w</code> firstly, then press <code>h</code> to switch to the left window (in the same way, <code>ctrl+w j</code> to the down window, <code>ctrl+w k</code> to the up window, <code>ctrl+w l</code> to the right window)</p></li><li><p>markdown<br>if I want to view the markdown file<br>  (1) install the <code>&quot;markdown-preview.vim&quot;</code> plugin<br>  (2) use <code>:MarkdownPreview</code> to view it in the browser</p></li><li><p>move the cursor<br>(1) move the cursor to the first line of a file<br><1> <code>:0</code> or <code>:1</code><br><2> <code>gg</code><br>  (2) move the cursor to the last line of a file<br><1> :<br><2> <code>G</code><br><3> <code>shift+g</code><br>  (3) move the cursor to the head of a line<br><1> <code>Home</code><br><2> <code>^</code> also <code>shift+6</code><br><3> <code>0</code><br>  (4) move the cursor to the tail of a line<br><1> <code>End</code><br><2> <code>shift+4</code> to move the cursor to the tail of the current line<br>  (5) shortcuts: search<br><code>:/&lt;word you search&gt;</code><br>  (6) open file<br>if vim is not launched:<br>  <code>vim &lt;file1_name&gt; &lt;file2_name&gt; &lt;file3_name&gt; ...</code><br>if vim is launched:<br>  <code>:open &lt;file_name&gt;</code><br>  (7) switch files in the opened files<br>switch files in the last two opened files:<br>  <code>ctrl + 6</code><br>next file<br>  <code>:bn</code><br>last file<br>  <code>:bp</code><br>  (8) revoke<br>revoke the last operation<br>  <code>:n</code><br>  <code>n</code><br>  <code>u</code></p></li><li><p>recover the revoke operation</p><pre><code>`ctrl + r`</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在vim中多开窗口并切换&lt;/p&gt;
&lt;p&gt;(1) use &lt;code&gt;:sp&lt;/code&gt; or &lt;code&gt;:vs&lt;/code&gt; to split the windows&lt;br&gt;(2) press the &lt;code&gt;ctrl+w&lt;/code&gt; first</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SVD奇异值分解</title>
    <link href="http://example.com/2021/02/02/SVD%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/"/>
    <id>http://example.com/2021/02/02/SVD%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/</id>
    <published>2021-02-02T12:14:55.000Z</published>
    <updated>2021-02-02T14:13:04.841Z</updated>
    
    <content type="html"><![CDATA[<p>奇异值分解是线性代数中一种重要的矩阵分解方法，本文通过一个具体的例子来说明如何对一个矩阵A进行奇异值分解。</p><p>首先，对于一个m*n的矩阵，如果存在正交矩阵U(m*m阶)和V(n*n阶)，使得(1)式成立：</p><script type="math/tex; mode=display">\begin{equation}\begin{split}A &= UΣV^T\end{split}\end{equation}\tag{1}</script><p>则将式(1)的过程称为奇异值分解，其中$Σ_{mn}=\begin{bmatrix}a &amp; b\\c &amp; d\end{bmatrix}$，且$Σ_1=diag(σ_1,σ_2,…,σ_r)$，U和V分别称为A的左奇异向量矩阵和右奇异向量矩阵。下面用一个具体的例子来说明如何得到上述的分解。</p><p>对于矩阵$A=\begin{bmatrix}1&amp;1\\1&amp;1\\0&amp;0\end{bmatrix}$,</p><p>第一步计算U，计算矩阵$AA^T=\begin{bmatrix}2&amp;2&amp;0\\2&amp;2&amp;0\\0&amp;0&amp;0\end{bmatrix}$，对其进行特征分解，分别得到特征值4，0，0和对应的特征向量$[\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0]^T$,$[-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0]^T$,$[0,0,1]^T$，可以得到$U=\begin{bmatrix}\frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}}&amp;0\\\frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}&amp;0\\0&amp;0&amp;1\end{bmatrix}$</p><p>第二步计算V，$A^TA=\begin{bmatrix}2&amp;2\\2&amp;2\end{bmatrix}$，对其进行特征分解，分别得到特征值4，0和对应的特征向量$[\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}]^T$，$[-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}]^T$，可以得到$V=\begin{bmatrix}\frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}}\\\frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}\end{bmatrix}$</p><p>第三部计算$Σ_{mn}=\begin{bmatrix}Σ_1&amp;0\\0&amp;0\end{bmatrix}$，其中$Σ_1=diag(σ_1,σ_2,…,σ_r)$是将第一或第二步求出的非零特征值从大到小排列后开根号的值，这里$Σ=\begin{bmatrix}2&amp;0\\0&amp;0\\0&amp;0\end{bmatrix}$</p><p>最终，我们可以得到A的奇异值分解</p><script type="math/tex; mode=display">\begin{equation}\begin{split}A &= UΣV^T=\begin{bmatrix}\frac{1}{\sqrt{2}}&-\frac{1}{\sqrt{2}}&0\\\frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}&0\\0&0&1\end{bmatrix}\begin{bmatrix}2&0\\0&0\\0&0\end{bmatrix}\begin{bmatrix}\frac{1}{\sqrt{2}}&-\frac{1}{\sqrt{2}}\\\frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}\end{bmatrix}^T=\begin{bmatrix}1&1\\1&1\\0&0\end{bmatrix}\end{split}\end{equation}</script><blockquote><p><strong>矩阵的特征值分解和奇异值分解有什么区别？</strong></p></blockquote><p>首先，特征值只能作用在一个m*<em>m的正方矩阵上，而奇异值分解则可以作用在一个m</em>*n的长方矩阵上。其次，奇异值分解同时包含了<strong>旋转</strong>、<strong>缩放</strong>和<strong>投影</strong>三种作用，(1)式中，U和V都起到了对A旋转的作用，而Σ起到了对A缩放的作用。特征值分解只有缩放的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;奇异值分解是线性代数中一种重要的矩阵分解方法，本文通过一个具体的例子来说明如何对一个矩阵A进行奇异值分解。&lt;/p&gt;
&lt;p&gt;首先，对于一个m*n的矩阵，如果存在正交矩阵U(m*m阶)和V(n*n阶)，使得(1)式成立：&lt;/p&gt;
&lt;script type=&quot;math/tex; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>k-core算法</title>
    <link href="http://example.com/2021/01/28/k-core%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/01/28/k-core%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-28T09:09:15.000Z</published>
    <updated>2021-01-28T14:25:25.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k-core算法"><a href="#k-core算法" class="headerlink" title="k-core算法"></a>k-core算法</h1><p>在图论中，k-degenerate（k简并）图是一种每个子图都有一个度不超过k的顶点的无向图，即子图中的某个顶点接触子图的k条或更少的边。图的degeneracy（简并度）是k简并的k的最小值。图的简并度是对它的稀疏程度的度量，并且是在其他稀疏度量的常数因子内，例如图的树状度。</p><p>简并度也被称为k-core数（num）、宽度（width）、和连锁（linkage），本质上与着色数（coloring number）或Szekeres-Wilf number（以Szekeres和Wilf(1968)命名）相同。k简并图也被称为k-inductive（k归纳）图。图的简并度可以通过反复删除最小度顶点的算法在线性时间内计算。去掉所有小于k度的顶点后剩下的连通分量称为图的k-cores（k核），图的简并度为具有k核的k的最大值。</p><p>如图所示是一张2-core图，每个顶点在其左边最多有两个邻居，因此任何子图的最右顶点的度最多为2。它的2核，即反复删除度数小于2的顶点后剩下的子图，是阴影的。</p><p>正如Matula &amp; Beck（1983）所描述的，在线性时间内，通过使用一个桶队列反复寻找并移除最小度的顶点，可以找到优化排序着色数的有限图G的顶点排序。那么简并度就是任何顶点在被移除时的最高度。设图中的节点数为n。更详细地说，该算法是这样进行的：</p><ul><li>初始化一个输出列表L。</li><li>对G中的每个顶点v计算一个数字dv，即v不存在于l中的邻居数。最初，这些数字只是顶点的度数。</li><li>初始化一个数组D，使D[i]包含一个不在L中dv = i的顶点v的列表。</li><li>将k初始化为0。</li><li>重复n次:<ul><li>扫描阵列单元D[0]， D[1]，…直到找到一个D[i]非空的i为止。</li><li>从D[i]中选择一个顶点v。在L的开头加上v，然后从D[i]中删除v。</li><li>对于v的每一个未在L中的相邻w，从dw中减去1，然后将w移到对应dw新值的D单元中。</li></ul></li></ul><p>在算法的最后，k包含G的简并性，L包含一个顶点列表，该顶点以最优的着色数排序。G的i核是L的前缀，由k先取大于等于i的值后添加到L的顶点组成。初始化变量L, dv, D和k可以很容易地在线性时间内完成。查找每个连续移除的顶点v，并调整包含v的邻居的D的单元，所花费的时间与该步骤dv的值成正比；但是这些值的总和就是图上的边的数量(每条边对后面的顶点的总和都有贡献)，所以总时间是线性的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;k-core算法&quot;&gt;&lt;a href=&quot;#k-core算法&quot; class=&quot;headerlink&quot; title=&quot;k-core算法&quot;&gt;&lt;/a&gt;k-core算法&lt;/h1&gt;&lt;p&gt;在图论中，k-degenerate（k简并）图是一种每个子图都有一个度不超过k的顶点的无向图</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Boss直聘折腾</title>
    <link href="http://example.com/2021/01/28/Boss%E7%9B%B4%E8%81%98%E6%8A%98%E8%85%BE/"/>
    <id>http://example.com/2021/01/28/Boss%E7%9B%B4%E8%81%98%E6%8A%98%E8%85%BE/</id>
    <published>2021-01-28T08:59:31.000Z</published>
    <updated>2021-02-10T03:48:00.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Boss直聘折腾记录"><a href="#Boss直聘折腾记录" class="headerlink" title="Boss直聘折腾记录"></a>Boss直聘折腾记录</h1><p>非出于本心，需要获得用户的简历（内心一百万个不愿意）。。。本人绝不使用这些数据用于任何研究，手中也绝不留存任何信息，仅当技术学习，如有侵权，务必直接联系本人。</p><ul><li>第一步登录boss直聘企业账号，发布职位，即可获取推荐牛人。</li><li>首先直接考虑访问url，不过boss直聘的反扒策略肯定不允许如此简单的方法，页面内容都是由Cookie生成的，所以此方法行不通。</li><li>其次考虑selenium控制浏览器，不过这种方法每次都需要打开新页面，就得重复扫码登录，无法完成自动化运行，舍弃该方法。</li><li>最后经过M老师指点，采用TamperMonkey的方法，在其中编写JavaScript脚本，截取相关代码，并模拟点击行为，最后在chrome的console中成功获取所需内容。为了将console中的内容保存到本地，采用了命令行<code>google-chrome --enable-logging --v=1</code>保存chrome console log文件，这样就可以下一步的数据提取了，使用Xml、BeautifulSoup等方法。为了保护相关人员权益，避免风险，不公开JavaScript脚本，恳请见谅。</li></ul><p>在整个过程中，还是学习到JavaScript、TamperMonkey的知识，感谢M老师和震哥的指点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Boss直聘折腾记录&quot;&gt;&lt;a href=&quot;#Boss直聘折腾记录&quot; class=&quot;headerlink&quot; title=&quot;Boss直聘折腾记录&quot;&gt;&lt;/a&gt;Boss直聘折腾记录&lt;/h1&gt;&lt;p&gt;非出于本心，需要获得用户的简历（内心一百万个不愿意）。。。本人绝不使用这些数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>github用户分析</title>
    <link href="http://example.com/2021/01/25/github%E7%94%A8%E6%88%B7%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/01/25/github%E7%94%A8%E6%88%B7%E5%88%86%E6%9E%90/</id>
    <published>2021-01-25T08:22:50.000Z</published>
    <updated>2021-01-25T10:20:55.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>Github作为全球最大的开源代码托管平台，存在着非常多的技术人员和宝贵的项目，这些都是非常难得的分析资源，对它们进行分析具有非常高的价值。</p><h2 id="用户分析"><a href="#用户分析" class="headerlink" title="用户分析"></a>用户分析</h2><p>鉴于Github用户过多，进行全量的分析是不现实的。由于最近团队在洞察Rust社区，选择对其中的贡献者进行分析。首先需要获得所有的Rust贡献者，这里有两种方法获得。</p><p>（1）爬取Crates.io（Rust社区所有crates的介绍网站）上的所有贡献者信息，可以有API来获取。不过这种方法需要进行长时间的爬取，比较繁琐。</p><p>（2）Rust官方有一个<a href="https://github.com/rust-lang/thanks">thanks</a>仓库，里面可以获得所有的贡献者名称。可以按照该仓库的使用介绍来获得ALL-TIME的贡献者名称。</p><p>得到具体的用户login后，可以调用Github API来获得贡献者的基本信息和相关关系。其中用户间的的关系我首先使用了following关系（后续可以添加follows、sponsors、sponsoring关系等），使用<code>https://api.github.com/users/&lt;user-login&gt;/following</code>来下载关系信息，使用<code>https://api.github.com/users/&lt;user-login&gt;</code>来下载基本信息。</p><p>得到用户的基本信息和相互的关系信息后，以人为节点建立知识图谱。个人偏好的工具有Networkx和Neo4j，都是非常好用的软件，其中Networkx可以使用python调用，Neo4j具有一套自己的图数据库系统。简单进行分析的话我选择Networkx。</p><p>从基本信息文件中抽取login作为节点名称，id、node_id、name、compony、blog、location、email、twitter_username、public_repos、public_gists、followers、following、bio、created_at、updated_at、avatar_url、html_url作为节点属性，建立单个节点。</p><p>从关系信息文件中抽取following关系作为两个节点之间的联系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h1&gt;&lt;p&gt;Github作为全球最大的开源代码托管平台，存在着非常多的技术人员和宝贵的项目，这些都是非常难得的分析资源，对它们进行分析具</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在linux终端优雅地打印JSON文件</title>
    <link href="http://example.com/2021/01/25/%E5%9C%A8linux%E7%BB%88%E7%AB%AF%E4%BC%98%E9%9B%85%E5%9C%B0%E6%89%93%E5%8D%B0JSON%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/01/25/%E5%9C%A8linux%E7%BB%88%E7%AB%AF%E4%BC%98%E9%9B%85%E5%9C%B0%E6%89%93%E5%8D%B0JSON%E6%96%87%E4%BB%B6/</id>
    <published>2021-01-25T07:30:53.000Z</published>
    <updated>2021-01-25T07:45:17.040Z</updated>
    
    <content type="html"><![CDATA[<p>JSON 文件非常棒，因为它们以人类可读的格式存储数据集合。然而，如果 JSON 文件被最小化过，那么阅读 JSON 文件可能会很痛苦。以下面的JSON文件为例。</p><pre><code>&#123;&quot;login&quot;: &quot;gperinazzo&quot;, &quot;id&quot;: 9922687, &quot;node_id&quot;: &quot;MDQ6VXNlcjk5MjI2ODc=&quot;, &quot;avatar_url&quot;: &quot;https://avatars0.githubusercontent.com/u/9922687?v=4&quot;, &quot;gravatar_id&quot;: &quot;&quot;, &quot;url&quot;: &quot;https://api.github.com/users/gperinazzo&quot;, &quot;html_url&quot;: &quot;https://github.com/gperinazzo&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/users/gperinazzo/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/users/gperinazzo/following&#123;/other_user&#125;&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/users/gperinazzo/gists&#123;/gist_id&#125;&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/users/gperinazzo/starred&#123;/owner&#125;&#123;/repo&#125;&quot;, &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/gperinazzo/subscriptions&quot;, &quot;organizations_url&quot;: &quot;https://api.github.com/users/gperinazzo/orgs&quot;, &quot;repos_url&quot;: &quot;https://api.github.com/users/gperinazzo/repos&quot;, &quot;events_url&quot;: &quot;https://api.github.com/users/gperinazzo/events&#123;/privacy&#125;&quot;, &quot;received_events_url&quot;: &quot;https://api.github.com/users/gperinazzo/received_events&quot;, &quot;type&quot;: &quot;User&quot;, &quot;site_admin&quot;: false, &quot;name&quot;: null, &quot;company&quot;: null, &quot;blog&quot;: &quot;&quot;, &quot;location&quot;: null, &quot;email&quot;: &quot;gperinazzo@gmail.com&quot;, &quot;hireable&quot;: null, &quot;bio&quot;: null, &quot;twitter_username&quot;: null, &quot;public_repos&quot;: 21, &quot;public_gists&quot;: 0, &quot;followers&quot;: 4, &quot;following&quot;: 0, &quot;created_at&quot;: &quot;2014-11-24T01:48:29Z&quot;, &quot;updated_at&quot;: &quot;2020-11-08T00:34:34Z&quot;&#125;</code></pre><p>计算机可以很容易地读取它。即使是人也能读，但如果 JSON 文件以合适的格式显示，那么阅读就会简单很多。理想中的 JSON 文件应该是这样读的：</p><pre><code>&#123;  &quot;login&quot;: &quot;gperinazzo&quot;,  &quot;id&quot;: 9922687,  &quot;node_id&quot;: &quot;MDQ6VXNlcjk5MjI2ODc=&quot;,  &quot;avatar_url&quot;: &quot;https://avatars0.githubusercontent.com/u/9922687?v=4&quot;,  &quot;gravatar_id&quot;: &quot;&quot;,  &quot;url&quot;: &quot;https://api.github.com/users/gperinazzo&quot;,  &quot;html_url&quot;: &quot;https://github.com/gperinazzo&quot;,  &quot;followers_url&quot;: &quot;https://api.github.com/users/gperinazzo/followers&quot;,  &quot;following_url&quot;: &quot;https://api.github.com/users/gperinazzo/following&#123;/other_user&#125;&quot;,  &quot;gists_url&quot;: &quot;https://api.github.com/users/gperinazzo/gists&#123;/gist_id&#125;&quot;,  &quot;starred_url&quot;: &quot;https://api.github.com/users/gperinazzo/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,  &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/gperinazzo/subscriptions&quot;,  &quot;organizations_url&quot;: &quot;https://api.github.com/users/gperinazzo/orgs&quot;,  &quot;repos_url&quot;: &quot;https://api.github.com/users/gperinazzo/repos&quot;,  &quot;events_url&quot;: &quot;https://api.github.com/users/gperinazzo/events&#123;/privacy&#125;&quot;,  &quot;received_events_url&quot;: &quot;https://api.github.com/users/gperinazzo/received_events&quot;,  &quot;type&quot;: &quot;User&quot;,  &quot;site_admin&quot;: false,  &quot;name&quot;: null,  &quot;company&quot;: null,  &quot;blog&quot;: &quot;&quot;,  &quot;location&quot;: null,  &quot;email&quot;: &quot;gperinazzo@gmail.com&quot;,  &quot;hireable&quot;: null,  &quot;bio&quot;: null,  &quot;twitter_username&quot;: null,  &quot;public_repos&quot;: 21,  &quot;public_gists&quot;: 0,  &quot;followers&quot;: 4,  &quot;following&quot;: 0,  &quot;created_at&quot;: &quot;2014-11-24T01:48:29Z&quot;,  &quot;updated_at&quot;: &quot;2020-11-08T00:34:34Z&quot;&#125;</code></pre><p>可以使用大多数的文本编辑器和一些插件以合适的格式显示它。然而，如果在终端中，或者想在 shell 脚本中这么做，事情会有所不同。对于一个已最小化过的 JSON 文件，有同样的办法在 Linux 终端中漂亮地输出它。</p><p>jq 是一个命令行 JSON 处理器。可以用它来切分、过滤、映射和转换结构化数据。可以使用 apt 命令在 Ubuntu 上安装它：</p><pre><code>sudo apt install jqjq . ***.json</code></pre><p>或者</p><pre><code>cat ***.json | jq</code></pre><p>如果想用漂亮的格式修改原来的 JSON 文件，可以把解析后的输出结果用管道传送到一个新的文件中，然后覆盖原来的 JSON 文件。</p><pre><code>jq . ***.json &gt; ###.json</code></pre><p>对一个格式良好的 JSON 文件进行最小化，可以使用选项 -c。</p><pre><code>jq -c &lt; ###.json</code></pre><p>如果系统中安装有python3，可以再终端中使用以下命令：</p><pre><code>python3 -m json.tool ***.json</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JSON 文件非常棒，因为它们以人类可读的格式存储数据集合。然而，如果 JSON 文件被最小化过，那么阅读 JSON 文件可能会很痛苦。以下面的JSON文件为例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#123;&amp;quot;login&amp;quot;: &amp;quot;gperinazz</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>keyword_extraction</title>
    <link href="http://example.com/2021/01/12/keyword-extraction/"/>
    <id>http://example.com/2021/01/12/keyword-extraction/</id>
    <published>2021-01-12T06:14:54.000Z</published>
    <updated>2021-01-12T12:02:45.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关键词提取"><a href="#关键词提取" class="headerlink" title="关键词提取"></a>关键词提取</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>关键字提取(又称关键字检测或关键字分析)是一种文本分析技术，可以自动从文本中提取最常用、最重要的单词和表达式，它有助于总结文本内容和识别讨论的主要话题。  </p><p>文本分析使用带有自然语言处理(NLP)的机器学习人工智能(AI)来分解人类语言，使其能够被机器理解和分析。关键字分析可以从各种文本中找到关键字：常规文件和商业报告，社交媒体评论，在线论坛和评论，新闻报道，等等。假设您想分析关于您的产品的数千条在线评论。关键字提取可以帮助您筛选整个数据集，并在几秒钟内获得最适合描述每个评论的词。通过这种方式，您可以很容易地自动地看到您的客户最经常提到的内容，从而为您的团队节省数小时的手工处理时间。</p><p>有一些免费的词云生成器可以比较直观地体现关键词，例如<a href="https://monkeylearn.com/blog/word-art/">Word clouds</a>。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p>Simple Statistical Approaches</p><p>主要包括词频、词搭配和共现、TF-IDF(术语频率反向文档频率的缩写)和RAKE(快速自动关键字提取)，基于统计的方法只依赖于统计数据，可能会忽略那些只被提到一次但仍然应该被认为是相关的相关单词或短语。</p><p>1、词频</p><p>词频包括列出在一篇文章中重复次数最多的单词和短语。这对于很多目的都很有用，从在一组产品评审中识别反复出现的术语，到发现客户支持交互中最常见的问题。然而，词频方法认为文档只是一个“单词袋”，而不考虑与含义、结构、语法和单词序列相关的关键方面。例如，这种关键字提取方法无法检测到同义词，从而忽略了非常有价值的信息。</p><p>2、单词搭配和共现</p><p>也被称为N-gram统计，单词搭配和共现有助于理解文本的语义结构，并将多个单词算作一个单词。<br>搭配是指经常放在一起的词。最常见的搭配类型是bi-grams(两个相邻的词，如“客户服务”、“视频电话”或“电子邮件通知”)和trig(三个词组成的组，如“易于使用”或“社交媒体渠道”)。<br>另一方面，共现现象是指在同一语料库中倾向于共现的单词。它们不一定是相邻的，但它们在语义上确实具有相似性。</p><p>3、TF-IDF</p><p>TF-IDF表示词频-逆文档频率，用来衡量文档集合中一个单词对文档的重要性。<br>该度量计算单词在文本中出现的次数(术语频率)，并将其与逆向文档频率(该单词在整个数据集中的罕见或常见程度)进行比较，将这两个量相乘就提供了文档中单词的TF-IDF分数。分数越高，这个词就越与文档相关。<br>当涉及到关键字提取时，这个指标可以帮助您识别文档中最相关的词(得分较高的词)，并将它们视为关键词。</p><p>4、RAKE</p><p>快速自动关键字提取(RAKE)是一种著名的关键字提取方法，它使用stopwords和短语分隔符列表来检测一段文本中最相关的单词或短语，以以下文本为例:<br><em>Keyword extraction is not that difficult after all. There are many libraries that can help you with keyword extraction. Rapid automatic keyword extraction is one of those.</em><br>该方法所做的第一件事是将文本拆分为一个单词列表，并从该列表中删除stopwords。这将返回一个所谓内容词的列表。<br>假设我们的stopwords和短语分隔符列表如下:<br>stopwords = [is, not, that, there, are, can, you, with, of, those, after, all, one]</p><p>分隔符=[., ,]<br>然后，我们的8个内容词的列表将像这样:<br>content_words =[keyword, extraction, difficult, many, libraries, help, rapid, automatic]<br>然后，该算法以短语分隔符和停止词分隔文本，以创建候选表达式。所以，候选人的关键短语如下:<br><em>Keyword extraction is not that difficult after all. There are many libraries that can help you with keyword extraction. Rapid automatic keyword extraction is one of those.</em><br>一旦文本被分割，该算法就会创建一个单词共现矩阵。每一行显示一个给定的内容词与候选短语中每个其他内容词共现的次数。对于上面的例子，矩阵看起来像这样:</p><p><img src="https://monkeylearn.com/static/74b6799b8c44da2b1c0d2eb7f9fe27df/f3e6b/rake-matrix.png" alt="RAKE Matrix"></p><p>在这个矩阵建立之后，单词会得到一个分数。这一点可以计算为一个词的程度在矩阵(即共生的数量的总和词与其他词在文本内容),随着词频的次数(即这个词出现在文本),或作为其频率除以这个词的程度。<br>如果我们计算每个单词的学位分数除以频率分数，它们看起来会像这样:</p><p><img src="https://monkeylearn.com/static/996e4b1308bd28ed6d4d726a2d051b28/2cbcd/rake-frequency-score.png" alt="RAKE frequency score"></p><p>这些表达式也会给出一个分数，这个分数是每个单词的分数之和。如果我们要计算上面粗体部分的得分，它们会是这样的:</p><p><img src="https://monkeylearn.com/static/d7794d12e177691b52b6f24fecd98adc/1b198/rake-phrases.png" alt="RAKE phrases"></p><p>如果两个关键字或关键字短语以相同的顺序同时出现两次以上，不管关键字短语在原始文本中包含多少stopwords，都会创建一个新的关键字短语。该关键字的得分计算方式与单个关键字的得分计算方式相同。<br>如果一个关键字或关键字短语的分数属于top T分数，其中T是您想要提取的关键字的数目，则选择该关键字或关键字短语。根据<a href="https://www.researchgate.net/publication/227988510_Automatic_Keyword_Extraction_from_Individual_Documents">原始论文</a>，T默认了文件中三分之一的内容词。<br>对于上面的示例，该方法将返回前3个关键字，根据我们定义的分数，这将是rapid automatic keyword extraction(13.33)、keyword extraction(5.33)和many libraries(4.0)。</p></li><li><p>语言学方法</p><p>关键词提取方法通常利用关于文本及其包含的单词的语言信息。有时，使用词法或句法信息(例如单词的词性或句子的依赖语法表示中单词之间的关系)来确定应该提取哪些关键字。在某些情况下，某些PoS会得到更高的分数(例如名词和名词短语)，因为它们通常比其他类别包含更多关于文本的信息。</p></li><li><p>图论方法</p><p>基于图的关键字提取的基本思想总是相同的:根据从图的结构中获取的一些信息来度量顶点的重要性，从而提取最重要的顶点。<br>一旦建立了一个图，就该确定如何度量顶点的重要性了。有许多不同的选择，其中大部分在本文中处理。有些方法选择测量顶点的度数。<br>顶点的度等于边的数量或连接顶点的土地(也称为度)+边的数量开始的顶点(也称为度)除以最大度(=图的顶点数- 1)。这个公式来计算一个顶点的度:</p><p><strong>Dv = (Dvin + Dvout) / (N - 1)</strong></p><p><img src="https://monkeylearn.com/static/b140909a8a4315b075d71be77daa76ce/61b91/graph-with-degree%402x.png" alt="Numeric graph with degree"></p><p>其他一些方法测量到一个给定顶点的直接顶点的数量(称为邻域大小)。</p><p><img src="https://monkeylearn.com/static/f48741f2f58f80d67ba4333c05113ed3/6648e/graph-with-neighborhood-size%402x.png" alt="Numeric graph with neighborhood size"></p><p>无论选择的度量是什么，每个顶点都会有一个分数，它将决定是否将其作为关键字提取。<br>以以下文本为例:<br><em>Automatic1 graph-based2 keyword3 extraction4 is pretty5 straightforward6. A document7 is represented8 as a graph9 and a score10 is given11 to each of the vertices12 in the graph13. Depending14 on the score15 of a vertex16, it might be chosen17 as a keyword18.</em><br>如果我们衡量社区大小上面的示例图的依赖性只包含有实词(编号1 - 18在文本),提取的关键词会被自动等基于关键字提取自附近的大小头名词提取(等于3/17)是最高的。</p></li><li><p>机器学习方法</p><p>1、条件随机域<br>条件随机场(CRF)是一种统计方法，通过对文本中出现的单词序列的不同特征进行加权来学习模式。这种方法考虑上下文和不同变量之间的关系，以便作出预测。<br>使用条件随机场允许您创建复杂和丰富的模式。这种方法的另一个优点是它的泛化能力:一旦模型用某个领域的例子进行了训练，它就可以很容易地将它所学到的知识应用到其他领域。<br>缺点是，为了使用条件随机场，您需要有很强的计算能力来计算所有单词序列的所有特征的权重。</p><p>评估关键字提取器的性能<br>在评估关键字提取器的性能时，您可以使用机器学习中的一些标准指标:准确性、精度、召回率和F1分数。然而，这些指标并不能反映部分匹配;他们只考虑所提取的片段与该标记的正确预测之间的完美匹配。<br>幸运的是，还有一些其他指标能够捕获部分匹配。一个例子就是ROUGE。<br>ROUGE(面向回忆的基sting评价替补研究)是一组比较源文本和提取词之间不同参数(如重叠词的数量)的指标。参数包括序列的长度和数目，可以手动定义。</p></li><li><p>混合方法</p><p>混合之前的方法。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关键词提取&quot;&gt;&lt;a href=&quot;#关键词提取&quot; class=&quot;headerlink&quot; title=&quot;关键词提取&quot;&gt;&lt;/a&gt;关键词提取&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简</summary>
      
    
    
    
    
    <category term="NLP" scheme="http://example.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>nlp工具总结</title>
    <link href="http://example.com/2021/01/12/nlp%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/01/12/nlp%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-12T02:44:43.000Z</published>
    <updated>2021-01-12T06:06:38.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NLP工具总结"><a href="#NLP工具总结" class="headerlink" title="NLP工具总结"></a>NLP工具总结</h1><ul><li>MonkeyLearn相关解决方案</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NLP工具总结&quot;&gt;&lt;a href=&quot;#NLP工具总结&quot; class=&quot;headerlink&quot; title=&quot;NLP工具总结&quot;&gt;&lt;/a&gt;NLP工具总结&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MonkeyLearn相关解决方案&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql使用总结</title>
    <link href="http://example.com/2021/01/12/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/01/12/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-12T02:29:10.000Z</published>
    <updated>2021-01-12T02:40:48.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL使用总结"><a href="#MySQL使用总结" class="headerlink" title="MySQL使用总结"></a>MySQL使用总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL使用总结&quot;&gt;&lt;a href=&quot;#MySQL使用总结&quot; class=&quot;headerlink&quot; title=&quot;MySQL使用总结&quot;&gt;&lt;/a&gt;MySQL使用总结&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rust使用总结</title>
    <link href="http://example.com/2021/01/11/rust%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/01/11/rust%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-11T15:03:15.000Z</published>
    <updated>2021-01-11T15:15:39.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rust使用总结"><a href="#rust使用总结" class="headerlink" title="rust使用总结"></a>rust使用总结</h1><ul><li><p>Rust Report Card - 为你的 Rust 代码生成质量报告</p><p><strong>简介：</strong></p><p>官网<code>https://rust-reportcard.xuri.me</code>，Rust Report Card 服务，通过近 500 个代码检测项帮助分析你的 Rust 代码中的潜在质量问题，还可获得 badge 徽章。  </p><p>该服务基于 rust-clippy 中 定义的 lint 规则对 Rust 进行静态代码分析扫描，在 Rust 编译器检查的基础之上帮你更进一步，编写出更好的代码，检查内容涵盖可优化性能写法、可简化代码写法、代码惯用风格更符合最佳实践、未使用变量和 cargo 声明文件检查等。  </p><p>Rust Report Card 提供了增量代码扫描、代码质量评级、徽章生成、协议检查和内部开源 Rust 代码质量评分排行等功能。</p><p><strong>代码质量评级与得分规则：</strong></p><p>3+</p><p>评级   得分      Badge  </p><p>A+      &gt; 90   <img src="https://cdn.learnku.com/uploads/images/202101/11/74/fbdNH6ReY9.svg" alt="img"></p><p>A        &gt; 80   <img src="https://cdn.learnku.com/uploads/images/202101/11/74/5gVwuPoSeR.svg" alt="img"></p><p>B        &gt; 70   <img src="https://cdn.learnku.com/uploads/images/202101/11/74/k5EGbqGY21.svg" alt="img"></p><p>C        &gt; 60   <img src="https://cdn.learnku.com/uploads/images/202101/11/74/qGQsMIq2US.svg" alt="img"></p><p>D        &gt; 50   <img src="https://cdn.learnku.com/uploads/images/202101/11/74/BxiUd4710y.svg" alt="img"></p><p>E         &gt; 40  <img src="https://cdn.learnku.com/uploads/images/202101/11/74/q9QfwKrAM4.svg" alt="img"></p><p>F       &lt;= 40  <img src="https://cdn.learnku.com/uploads/images/202101/11/74/aCbYUmx0p4.svg" alt="img"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rust使用总结&quot;&gt;&lt;a href=&quot;#rust使用总结&quot; class=&quot;headerlink&quot; title=&quot;rust使用总结&quot;&gt;&lt;/a&gt;rust使用总结&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Rust Report Card - 为你的 Rust 代码生成质量报告&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>typescript使用总结</title>
    <link href="http://example.com/2021/01/11/typescript%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/01/11/typescript%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-11T13:46:51.000Z</published>
    <updated>2021-01-11T15:00:26.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Type-Script使用总结"><a href="#Type-Script使用总结" class="headerlink" title="Type Script使用总结"></a>Type Script使用总结</h1><ul><li>安装<code>typescript</code></li></ul><pre><code>sudo apt install npmsudo npm install -g typescript</code></pre><p>通过<code>tsc</code>命令确认安装完成</p><pre><code>tsc -v</code></pre><ul><li>运行<code>ts</code>文件</li></ul><pre><code>tsc ***.ts // 得到***.js文件node ***.js // 使用node命令执行js文件</code></pre><ul><li><p>运行<code>ts</code>文件出现以下错误</p><pre><code>Cannot find module &#39;fs&#39;</code></pre><p>执行以下命令：</p><pre><code>sudo npm install @types/node</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Type-Script使用总结&quot;&gt;&lt;a href=&quot;#Type-Script使用总结&quot; class=&quot;headerlink&quot; title=&quot;Type Script使用总结&quot;&gt;&lt;/a&gt;Type Script使用总结&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;code&gt;type</summary>
      
    
    
    
    
  </entry>
  
</feed>
